20221004 화요일 p.51~p.55 언어의 뜻은 기호의 집합으로 인코딩되지만 결국 문맥이 중요하다. 기호나 조합은 무궁무진한 가능성이 있다. 컴퓨터에서는 비트라는 2진법을 사용한다는 뜻의 바이너리와 숫자를 뜻하는 디지트가 합쳐진 말이 있다. / 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작을 논리연산이라고 한다. / 비트에 대해 사용할 수 있는 연산 규칙의 집합인 불리언대수가 있다. 'NOT,AND, OR,XOR ', 진리표를 사용해 시각적으로 보여줄 수 있다. XOR은 (A OR B) AND (NOT (A AND B))를 뜻한다

20221005 수요일 p.56~ P.62반 컴퓨터에서 입력을 항상 원하는 형태로 얻을 수는 없기 때문에 드모르간의 법칙이 유용할 때가 있다. 긍정적인 논리 '정논리' 부정적인 논리 '부논리' / 2진수는 2를 밑으로 하는 수 체계다. 10진수로는 5028이 네 자리 숫자고, 2진수로는 13비트 수가 된다. 10진수와 마찬가지로 2진수에서도 비트의 개수가 표현할 수 있는 값의 범위를 결정한다. 가장 작은 유효 비트를 LSB, 가장 큰 유효 비트를 MSB 라고 한다. 2진수에서도 각 비트를 LSB에서 MSB 쪽으로 더하며 결과가 1보다 크면 1을 다음 왼쪽 자리로 올린다. 001 + 101 = 110 . 서로 더한 결과는 두 비트를 XOR 한 값과 같고, 올림은 두 비트를 AND 한 값과 같다. 한 연산에서 올림까지 포함해 3개의 비트를 더하고 있다. 덧셈 결과가 비트의 개수로 표현할 수 있는 범위를 벗어나면 오버플로가 발생한다. 즉, MSB에서 올림이 발생했다는 뜻이다. 1001 과 1000을 더하면 10001이지만 왼쪽에 사용할 수 있는 비트가 없기 때문에 결과가 0001이 된다. 컴퓨터에 조건코드 레지스터 라는 것이 있어서 몇가지 이상한 정보를 담아둔다. 이런 정보 중에는 오버플로 비트가 있고, 이 비트에는 MSB에서 발생한 올림값이 들어간다. 이 비트값을 보면 오버플로가 발생했는지 알 수 있다.

20221006 목요일 p.62반 ~ p.69 2진수로 음수를 표현하는 방법을 살펴보자! / 음수와 양수를 구별하기 위해 부호를 사용한다. 우리는 가장 왼쪽 비트(MSB)를 부호에 사용하기로 멋대로 결정했다. 비트가 0이면 양수로 취급, 부호 비트가 1이면 음수로 취급하자. 그렇게 4비트로 총 15가지 음수와 양수를 표현할 수 있다. 이처럼 한 비트를 부호에 사용하고 나머지 비트를 수의 크기를 표현하는 방법을 부호와 크기 표현법이다. 이 사용법은 0을 표현하는 방식이 두가지라 비용 낭비고, XOR과 AND를 통한 덧셈 계산을 사용할 수가 없다. +1 과 -1을 더하고 싶어서 0001 + 1001 을 더하면 1010 이 되는데 이는 -2 값이 된다. 0이어야 하는데 !!!!! / 1의 보수 표현법을 알아보자. 이는 양수의 모든 비트를 뒤집는 방법이다. 7을 표현하기 위한 방법은 0111 인데, -7을 표현하기 위한 수는 1000 이렇게 된다. 이 표현법은 0을 두가지 방식으로 표현하고, MSB 쪽에서 올림이 발생한 경우에는 LSB로 올림을 전달해야 하고, 이를 순환 올림이라고 부른다. 덧셈 할때 잘 작용하나 약간 복잡하다. / 2의 보수 표현법을 알아보자 !!!! 어떤 수의 모든 비트를 다 뒤집고 거기서 1을 더해준다. 0을 표현하는 방법은 하나뿐이다! 2의 보수로 표현할 수 있는 값의 범위는 비트 개수가 늘어날 때마다 지수적으로 증가한다. / 실수를 표현하는 방법도 알아보자. 그 중에 고정소수점 표현법 !!! 2비트는 2진 소수점의 오른쪽에 있는 분수들을 표현하는 데 쓰고, 2비트는 왼쪽에 있는 숫자들을 표현하는데 쓴다. 잘 작동하지만 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많다. DSP 디지털 신호 처리 장치 등 특별 목적에 쓰이는 일부 컴퓨터는 쓰기도 한다. 그러나 범용컴퓨터는 플랑크 상수부터 아보가드로 수까지 표현할 수 있는 범위를 표현할 줄 알아야 하며, 고정소수점 표현법으로는 200비트정도가 필요하고 비용이 너무 많이 든다

20221008 토요일 p.70 ~ p.76반 부동소수점 표현법으로 과학적 표기법을 2진수에 적용한다. 수를 새롭게 해석하는 방법인데 10진수 소수점 왼쪽이 한 자리 뿐인 소수에 10을 몇번 거듭제곱한 값을 곱하는 방식으로 소수를 표현한다. 가수 부분은 2진 소수, 지수 부분은 2의 거듭제곱 횟수를 표현한다. 소수점의 위치가 같아보이지만 지수가 무엇인가에 따라 소수점 왼쪽 숫자의 자리가 1/10 일수도, 100,000일수도 있다. 소수점 위치가 정해져 잇지 않다고 말할 수 있다. 부동소수점 2진수 예시 1.101 이를 보면 비효율성을 알 수 있다. 모든 수를 표현하지도 못하고 가수의 한 패턴과 다른 패턴 사이의 값 차이가 커진다. 이 부정확한 계산을 어떻게 개선할지 수치해석이라는 수학 분야가 있긴하다. /부동소수점 수 시스템은 실수를 표현하는 표준 방법이고, 더 많은 비트를 사용하고, 각각 부호 비트를 사용한다. 다만 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있다. 낭비되는 비트 조합을 최소화하고 반올림을 쉽게 하는 IEEE 754 라는 표준이 있다. 정밀도를 높이고 싶어서 가수를 조정해서 맨 앞에 0이 없게 만드는 정규화를 실행한다. 두번째 트릭은 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략하는 것이다. 기본 정밀도 부동소수점 수가 있고, 2배 정밀도 부동소수점 수가 있다. 비트를 2배나 더 많이 사용한다는 비용을 지불한다. 이것들은 지수에 대해 부호 비트가 따로 존재하지 않는다. 편향값을 갖게 했다. 기본 정밀도의 편향값은 127 2배 정밀도 수의 평향값은 1023이다. 특별한 지숫값을 부여해 NaN 도 표현할 수 있다. / 2진 코드화한 10진수 시스템이 있다. 12를 BCD로 표현하면 0001 0010 이다. 디스플레이나 가속도 센서 등이 BCD를 이용한다. 2진수를 효율적으로 활용하지 못한다. /2진수를 다루는 쉬운 방법에 8진 표현법과 16진 표현법이 있다. 8진 표현법은 2진수 비트들을 3개씩 그룹으로 묶는다. 과거처럼 널리 쓰이진 않는다. 2진수를 표현하기 위해 쓰이는 수는 0과 1 두개이고, 8진수를 표현하고 위해 필요한 수는 0 ~ 7 8개가 필요하다. 16진수를 표현하기 위해선 0~15 숫자가 필요하다. 10,11,12,13,14,15 는 A,B,C,D,E,F 로 각각 표현한다 , /수를 변환하는 방법을 어떻게 표현할까? 0으로 시작하는 숫자는 8진 숫자다. 1부터 9 숫자로 시작한느 숫자는 10 진수다. 0x가 앞에 붙은 숫자는 16진수다.

20221009 일요일 p. 76반 ~ p.81 컴퓨터는 제대로 조직화된 비트들로 이뤄진다. 따라서 컴퓨터가 사용할 비트의 개수와 비트들의 조직을 결정해야 했다. 비트는 너무 작아서 기본 단위로 사용하기에는 유용성이 떨어진다. 따라서 비트를 좀 더 큰 덩어리로 만들었는데, 8비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 바이트라고 부른다. 큰 수를 가리키기 위해 사용하는 표준 용어도 존재한다. 키비, 메비, 기비, 테비 는 순서대로 2의 10제곱, 2의 20제곱, 2의 30제곱, 2의 40제곱을 뜻한다. / 컴퓨터는 항상 비트를 다루고 비트를 사용해 수와 같은 대상을 표현한다. 아스키코드는 모든 기호에 대해 7비트 수 값을 할당했다. 65는 대문자 A을 나타낸다. a는 97이다. 아스키 코드 표에서 글자를 출력하는데 쓰이지 않고 장치를 제어하기 위해 쓰이는 제어문자도 있다. 이 중 상당수는 통신 제어를 위한 문자다. 비트 가격이 떨어짐에 따라 문자에 16비트 코드를 부여하는 유니코드라는 새로운 표준이 만들어졌다. 그 후 21비트까지 확장됐지만, 이조차도 충분하지 않을 수 있다. / 유니코드 변환 형식 8비트 UTF-8 ,,, 유니코드는 문자 코드에 따라 각기 다른 인코딩을 사용해 굳이 16비트를 쓰면서까지 비트 낭비를 막는 문제를 해결한다. 인코딩은 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴을 뜻한다. UTF-8은 모든 아스키 코드를 8비트로 표현하기 때문에 아스키 데이터를 인코딩 할 때는 추가 공간이 필요하지 않다. 그리고 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩한다.

20221010 월요일 p. 82~ p. 83 UTF-8은 8비트 덩어리의 시퀀스로 인코딩한다. 첫번째 덩어리의 MSB 쪽에 있는 비트들이 8비트 덩어리 시퀀스의 길이를 표현하고 덩어리의 맨 앞을 식별하기 쉽다. 모든 아스키 문자는 7비트에 들어가기 때문에 덩어리를 하나만 사용해 표현할 수 있다. UTF-8로 인코딩할 때 7비트 안에 문자의 코드가 다 들어가기 때문에 덩어리를 하나만 사용하고 MSB를 0으로 설정한다. 2개의 8비트 덩어리를 사용할 때는 첫번째 덩어리의 MSB 3비트 를 110으로 시작하고, 두 번째 덩어리의 MSB 2비트는 10으로 시작한다. / UTF-8은 문자 A를 표현하는 비트들 2진수 0000000001000001 로부터 나온 숫자들 0x0041 을 표현하는 숫자들 즉, UTF-8 을 표현하기 위해 실제 UTF-8 로 인코딩한 0x41을 사용한다. 이제는 문자를 사용해 수를 표현할 수도 있다. 2진 데이터를 직접 보내는 것은 어렵다. 아스키 코드 중 상당수가 제어 문자로 되어있고, 이를 처리하는 방식이 달라야 했기 때문이다.

20221011 화요일 p. 83 반~ p. 85 출력 가능하게 변경한 인코딩은 쿼티드 프린터블 인코딩, QP 인코딩이라고도 한다. 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법이다. 이 인코딩을 사용하면 = 다음에 바이트의 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트 값을 표현한다. QP에서는 = 를 =3D 로 사용해야 한다. QP 인코딩 추가 규칙이 있다. 줄의 맨 끝에 탭과 공백 문자가 온다면 =09 =20 으로 표현해야만 한다. 인코딩된 데이터는 한 줄이 76자를 넘을 수 없다. 어떤 줄의 맨 뒤가 =로 끝나면 가짜 줄바꿈을 뜻한다. 수신 쪽에서 QP로 인코딩 된 데이터를 디코딩 할 때는 이 =를 제거하고 해석한다. / '베이스64 인코딩' QP 인코딩이 잘 작동하기는 하지만 1바이트를 표현하기 위해 3바이트를 사용한다. 그래서 비효율적이다. 베이스64 인코딩은 3바이트 데이터 총 24비트를 4개의 6비트 덩어리로 나눈다. 각 덩어리의 비트를 출력 가능한 문자를 할당해 표현한다. 이 인코딩은 모든 3바이트 조합을 4바이트 조합으로 변환할 수 있다. 원본 데이터 길이가 3바이트의 배수라는 보장은 없으니, 패딩 문자를 도입한다. 원본 데이터가 2바이트 남으면 끝에 = 를 붙이고, 1바이트 남으면 끝에 ==를 붙인다. / 'URL 인코딩' =가 특별한 기능에 해당하지 않을 때도 있다. %26 이나 %2F 가 이에 해당한다. 이런 값이 있는 이유는 URL 이라는 문맥에서 몇몇 문자가 특별한 의미를 지니기 때문이다. 이런 것들은 리터럴로 사용한다. URL 인코딩은 퍼센트 인코딩이라고도 부르는데, % 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩한다. 예를 들어 슬래시 문자는 URL에서 특별한 의미를 지닌다. 이 문자의 아스키 코드는47, 16진수로는 2F다. /를 URL에 사용하되 /가 표현하는 특별한 의미를 뜻하고 싶지는 않은 경우, /를 %2F라는 문자열로 대신한다.

20221016 일요일 p. 86 ~ p.90 색 표현을 할 때도 숫자를 사용한다. 컴퓨터 그래픽스는 전자 모눈종이에 점을 찍어서 그림을 만드는 과정이다. 각 격자에 찍는 점을 그림원소라 부르고, 픽셀이라 줄여 말한다. 빨, 노 , 파 광선을 섞어서 컴퓨터 모니터가 색을 만들어낸다. RGB 색 모델. 값이 0이면 빛을 끄고, 값이 1이면 빛을 킨다. 아무 빛도 없으면(0,0,0) 검은색이고, 모든 빛을 최대로 켜면(1,1,1) 흰색이다. 이처럼 빛을 혼합해 색을 표현하는 방식을 가산 색 시트템이라고 한다. 특정 빛의 광선(파장)을 서로 추가해 색을 만든다. 가산 색 시스템은 주 색이 청록색, 자홍색, 노란색이며 흰색 광선에서 각 색에 해당하지 않는 빛을 제거하면서 색을 만들어낸다. 가산 시스템이 더 많은 색을 만들어낸다. 인간의 눈은 생존을 위해 진화해온 아주 지저분한 기계장치다. 우리의 구분은 선형적이지 않으며, 전체적인 빛의 세기에 맞춰 눈의 응다바이 점차 변한다. 암순응이다. dark adaptation / 현대 컴퓨터는 색을 표현하는 데 24비트를 사용하고, 8비트로 나뉘며, 이 각 필드는 세가지 주요 색을 표현한다. 그러나 현대 컴퓨터가 24비트 단위로 계산을 수행할 수 없어서 32비트에 색을 넣어서 처리한다. 이때,, 사용하지 않는 8비트를 낭비하지 않기 위해 투명도를 표현하기로 한다. / 투명도 추가! 각 픽셀에 a라는 투명도 값을 추가했다. 알파는 수학적으로 0이상 1이하인 값이다. 0은 해당값이 완전히 투명하다는 뜻이고, 1은 완전히 불투명하다는 것이다. 여러 다른 알파값의 색을 합성해 새로운 색을 만들어내는 이 방법을 합성 계산법이라고 한다. 알파 값으로 1부터 255의 값을 사용했다. 빨, 노, 파 색 값을 그대로 저장하는 대신, 색값에 알파를 곱한 값을 저장했다. RGB로 빨간색이 200,0,0 이라면 투명도를 0.5로 하고 싶다. 그러면 100,0,0 의 값에 255*0.5 = 127 알파 값은 127이다. 알파값을 미리 곱한 값을 저장한다는 말은 픽셀을 사용할 때마다 알파를 곱하는 계산을 반복할 필요가 없다는 뜻이다. / 색 인코딩 ! 텍스트를 이용해 색을 표현하기 위해선, 16진 트리플렛으로 표현한다. #rrggbb 이렇게 8비트 색값을 두자리 문자로 된 16진 표기로 바꾼다. / 정리! 비트를 사용해 숫자, 문자, 색을 표현하는 방법을 배웠다. 2장에서는 컴퓨터를 이루는 물리적 구성요소를 이해하고 왜 컴퓨터가 애초부터 비트를 사용하는지 이해할때 도움이 될 수 있도록 하드웨어 기본을 배운다!!!!!!
