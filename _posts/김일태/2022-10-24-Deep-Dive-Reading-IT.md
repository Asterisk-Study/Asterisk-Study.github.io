---
title: "김일태 독서일지 : 모던 자바스크립트 Deep Dive"
layout: post
comments: true
categories: [김일태/독서일지]
tags: 김일태
---

### 1장. 프로그래밍

프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것<br/>

### 2장. 자바스크립트란?

렌더링이란 HTML, CSS, 자바스크립트로 작성된 문서를 해석해서 브라우저에 시각적으로 출력하는 것을 말함, 
때로는 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정(SSR:Service Side Rendering)을 가리키도 함<br/>
Ajax는 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식을 가능하게 함<br/>
jQuery의 등장으로 다소 번거롭고 논란이 있던 DOM을 더욱 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결됨<br/>

.....

.....

### 4장. 변수

자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.<br/>

변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름이다.<br/>

일반적으로 초기화란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. 
var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행된다. 
따라서 var 키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다.<br/>

변순 선언이 소스코드 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행한다. 
변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징을 변수 호이스팅이라 한다. 
변수 선언뿐 아니라 모든 식별자(변수, 함수, 클래스 등)는 호이스팅한다. 
모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.<br/>

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.<br/>

값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.<br/>

가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. - 매니지드 언어 - 메모리 누수 방지<br/>

### 5장. 표현식과 문

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.<br/>

크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. - 완료값<br/>

크롬 개발자 도구에서 표현식인 문은 평가된 값을 반환한다.<br/>

### 6장. 데이터 타입

데이터 타입이 필요한 이유
- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해서
- 값을 참조할 때 한 번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해서
- 메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해서

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 
그리고 재할당에 의해 변수의 타입은 언제든지 변할 수 있다. 
이러한 특징을 동적 타이핑이라 한다.<br/>
동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.<br/>

### 7장. 연산자

증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.<br/>
증가/감소(++/--) 연산자는 위치에 의미가 있다. 
- 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.
- 피연산자 뒤에 위치한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.

숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 
이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 부수 효과는 없다.<br/>

암묵적 타입 변환 // 타입 강제 변환<br/>

NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN을 사용한다.<br/>

Object.is 메소드는 일치 비교 연산자(===)와 비슷하게 작동하며 NaN 두 개를 비교하면 true를 반환하고 +0과 -0을 비교하면 false를 반환하는 더 예측 가능한 결과를 반환한다.<br/>

드 모르간의 법칙<br/>
논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한눈에 이해하기 어려울 때가 있다. 
이러한 경우 드 모르간의 법칙을 활용하면 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환할 수 있다.<br/>
- !(x || y) = (!x && !y)
- !(x && y) = (!x || !y)

typeof 연산자로 null 값을 연산해보면 "null"이 아닌 "object"를 반환한다는 데 주의하자. 
이것은 자바스크립트의 첫 번째 버전의 버그다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다. 
또 하나 주의해야 할 것이 있다. 
선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 undefined를 반환한다.<br/>

ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다. 
지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했다. 
음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 한다.<br/>

대부분의 연산자는 다른 코드에 영향을 주지 않는다. 
하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다. 
부수 효과가 있는 연산자는 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자다.<br/>

### 8장. 제어문

삼항 조건 연산자는 값으로 평가되는 표현식을 만든다. 따라서, 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 
하지만 if...else 문은 표현식이 아닌 문이다. 따라서, if...else 문은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다.<br/>

switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다. 
case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 
그리고 그 뒤에 실행할 문들을 위치시킨다.<br/>

switch 문의 표현식과 일치하는 case 문이 없다면 실행 순서는 default 문으로 이동한다. 
default 문은 선택사항으로, 사용할 수도 있고 사용하지 않을 수도 있다.

```js
switch(표현식) {
  case 표현식1:
    switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;
  case 표현식2:
    switch 문의 표현식과 표현시2가 일치하면 실행될 문;
    break;
  default:
    switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
}
```

if...else 문의 조건식은 불리언 값으로 평가되어야 하지만 switch 문의 표현식은 불리언 값 보다는 문자열이나 숫자 값인 경우가 많다. 
다시 말해, if...else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정한다. 
switch 문은 논리적 참, 거짓 보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 사용한다.<br/>
switch 문의 표현식의 평가 결과와 일치하는 case 문으로 실행 흐름이 이동하여 문을 실행하지만 break 문을 사용하지 않으면 switch 문을 탈출하지 않고 
switch 문이 끝날 때까지 이후의 모든 case 문과 default 문을 실행한다. 
이를 폴스루라 한다.<br/>

for 문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다.<br/>
while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.<br/>
무한루프에 탈출하기 위해서는 코드 블록 내에 if 문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다.<br/>

do...while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다.

```js
do {
    console.log(count); // 0 1 2
    count++;
} while (count<3);
```
continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. 
break 문처럼 반복문을 탈출하지는 않는다.<br/>

### 9장 타입 변환가 단축 평가

자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 
개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(explicit corecion) 또는 타입 캐스팅(type casting)이라 한다.<br/>

개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다. 
이를 암묵적 타입 변환(implicit coercion) 또는 타입 강제 변환(type coercion)이라 한다.<br/>

명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다. 
원시 값은 변경 불가능한 값이므로 변경할 수 없다. 
타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.<br/>

때로는 명시적 타입 변환보다 암묵적 타입 변환이 가독성 측면에서 더 좋을 수 있다. 
예를 들어, 자바스크립트 문법을 잘 이해하고 있는 개발자에게는 (10).toString()보다 10 +''이 더욱 간결하고 이해하기 쉽다.<br/>

자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.<br/>

자바스크립트 엔진은 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 
이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이다.<br/>

if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참/거짓으로 평가되어야하는 표현식이다. 
자바스크립트 엔진은 조건식의 평가 또는 결과를 불리언 타입으로 암묵적 타입 변환한다. 
이때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.<br/>
false로 평가되는 Falsy 값
- false
- undefined
- null
- 0, -0
- NaN
- ''(빈 문자열)

parseInt, parseFloat 함수는 문자열만 숫자 타입으로 변환 가능<br/>

! 부정 논리 연산자를 두 번 사용하면 불리언 타입으로 변환 가능<br/>

논리곱(&&) 연산자와 논리합(||) 연산자는 논리 연산 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다. 
이를 단축 평가라한다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.

단축 평가 표현식 | 평가 결과
-|-
true || anything | true
false || anything | anything
true && anything | anything
false && anything | false



