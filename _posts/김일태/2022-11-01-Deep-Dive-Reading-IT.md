---
title: "김일태 독서일지 : 모던 자바스크립트 Deep Dive"
layout: post
comments: true
categories: [김일태/독서일지]
tags: 김일태
---

### 1장. 프로그래밍

프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것<br/>

### 2장. 자바스크립트란?

렌더링이란 HTML, CSS, 자바스크립트로 작성된 문서를 해석해서 브라우저에 시각적으로 출력하는 것을 말함, 
때로는 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정(SSR:Service Side Rendering)을 가리키도 함<br/>
Ajax는 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식을 가능하게 함<br/>
jQuery의 등장으로 다소 번거롭고 논란이 있던 DOM을 더욱 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결됨<br/>

.....

.....

### 4장. 변수

자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.<br/>

변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름이다.<br/>

일반적으로 초기화란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. 
var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행된다. 
따라서 var 키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다.<br/>

변순 선언이 소스코드 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행한다. 
변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징을 변수 호이스팅이라 한다. 
변수 선언뿐 아니라 모든 식별자(변수, 함수, 클래스 등)는 호이스팅한다. 
모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.<br/>

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.<br/>

값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.<br/>

가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. - 매니지드 언어 - 메모리 누수 방지<br/>

### 5장. 표현식과 문

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.<br/>

크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. - 완료값<br/>

크롬 개발자 도구에서 표현식인 문은 평가된 값을 반환한다.<br/>

### 6장. 데이터 타입

데이터 타입이 필요한 이유
- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해서
- 값을 참조할 때 한 번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해서
- 메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해서

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 
그리고 재할당에 의해 변수의 타입은 언제든지 변할 수 있다. 
이러한 특징을 동적 타이핑이라 한다.<br/>
동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.<br/>

### 7장. 연산자

증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.<br/>
증가/감소(++/--) 연산자는 위치에 의미가 있다. 
- 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.
- 피연산자 뒤에 위치한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.

숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 
이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 부수 효과는 없다.<br/>

암묵적 타입 변환 // 타입 강제 변환<br/>

NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN을 사용한다.<br/>

Object.is 메소드는 일치 비교 연산자(===)와 비슷하게 작동하며 NaN 두 개를 비교하면 true를 반환하고 +0과 -0을 비교하면 false를 반환하는 더 예측 가능한 결과를 반환한다.<br/>

드 모르간의 법칙<br/>
논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한눈에 이해하기 어려울 때가 있다. 
이러한 경우 드 모르간의 법칙을 활용하면 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환할 수 있다.<br/>
- !(x || y) = (!x && !y)
- !(x && y) = (!x || !y)

typeof 연산자로 null 값을 연산해보면 "null"이 아닌 "object"를 반환한다는 데 주의하자. 
이것은 자바스크립트의 첫 번째 버전의 버그다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다. 
또 하나 주의해야 할 것이 있다. 
선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 undefined를 반환한다.<br/>

ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다. 
지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했다. 
음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 한다.<br/>

대부분의 연산자는 다른 코드에 영향을 주지 않는다. 
하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다. 
부수 효과가 있는 연산자는 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자다.<br/>

### 8장. 제어문

삼항 조건 연산자는 값으로 평가되는 표현식을 만든다. 따라서, 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 
하지만 if...else 문은 표현식이 아닌 문이다. 따라서, if...else 문은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다.<br/>

switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다. 
case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 
그리고 그 뒤에 실행할 문들을 위치시킨다.<br/>

switch 문의 표현식과 일치하는 case 문이 없다면 실행 순서는 default 문으로 이동한다. 
default 문은 선택사항으로, 사용할 수도 있고 사용하지 않을 수도 있다.

```js
switch(표현식) {
  case 표현식1:
    switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;
  case 표현식2:
    switch 문의 표현식과 표현시2가 일치하면 실행될 문;
    break;
  default:
    switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
}
```

if...else 문의 조건식은 불리언 값으로 평가되어야 하지만 switch 문의 표현식은 불리언 값 보다는 문자열이나 숫자 값인 경우가 많다. 
다시 말해, if...else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정한다. 
switch 문은 논리적 참, 거짓 보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 사용한다.<br/>
switch 문의 표현식의 평가 결과와 일치하는 case 문으로 실행 흐름이 이동하여 문을 실행하지만 break 문을 사용하지 않으면 switch 문을 탈출하지 않고 
switch 문이 끝날 때까지 이후의 모든 case 문과 default 문을 실행한다. 
이를 폴스루라 한다.<br/>

for 문은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다.<br/>
while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.<br/>
무한루프에 탈출하기 위해서는 코드 블록 내에 if 문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다.<br/>

do...while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다.

```js
do {
    console.log(count); // 0 1 2
    count++;
} while (count<3);
```
continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. 
break 문처럼 반복문을 탈출하지는 않는다.<br/>

### 9장 타입 변환가 단축 평가

자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 
개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(explicit corecion) 또는 타입 캐스팅(type casting)이라 한다.<br/>

개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다. 
이를 암묵적 타입 변환(implicit coercion) 또는 타입 강제 변환(type coercion)이라 한다.<br/>

명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아니다. 
원시 값은 변경 불가능한 값이므로 변경할 수 없다. 
타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.<br/>

때로는 명시적 타입 변환보다 암묵적 타입 변환이 가독성 측면에서 더 좋을 수 있다. 
예를 들어, 자바스크립트 문법을 잘 이해하고 있는 개발자에게는 (10).toString()보다 10 +''이 더욱 간결하고 이해하기 쉽다.<br/>

자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.<br/>

자바스크립트 엔진은 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 
이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이다.<br/>

if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참/거짓으로 평가되어야하는 표현식이다. 
자바스크립트 엔진은 조건식의 평가 또는 결과를 불리언 타입으로 암묵적 타입 변환한다. 
이때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.<br/>
false로 평가되는 Falsy 값
- false
- undefined
- null
- 0, -0
- NaN
- ''(빈 문자열)

parseInt, parseFloat 함수는 문자열만 숫자 타입으로 변환 가능<br/>

! 부정 논리 연산자를 두 번 사용하면 불리언 타입으로 변환 가능<br/>

논리곱(&&) 연산자와 논리합(||) 연산자는 논리 연산 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다. 
이를 단축 평가라한다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.

단축 평가 표현식 | 평가 결과
-|-
true || anything | true
false || anything | anything
true && anything | anything
false && anything | false

### 10장. 객체 리터럴

원시 타입의 값, 즉 원시 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값이다.

- 프로퍼티 : 객체의 상태를 나타내는 값(data)
- 메서드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실체를 말한다. 
객체지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다. 
클래스는 인스턴스를 생성하기 위한 탬플릿의 역할을 한다. 
인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어다.<br/>

객체 리터럴의 중괄호는 코드 블럭을 의미하지 않는다는 데 주의하자. 
코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다. 
하지만 객체 리터럴은 값으로 평가되는 표현식이다. 
따라서 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.<br/>

객체는 프로퍼티의 집함이며, 프로퍼티는 키와 값으로 구성된다. 
프로퍼티를 나열할 때는 쉼표(,)로 구분한다. 
일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나 사용해도 좋다.<br/>
프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 다음과 같다.

- 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

프로퍼티 키는 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.<br/>

프로퍼티에 접근하는 방법은 다음과 같이 두 가지다.
- 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법(dot notation)
- 대괄호 프로퍼티 접근 연산자([...])를 사용하는 대괄호 표기법(bracket notation)

대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 
대괄호 프로퍼티 접근 연산자 내에 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석한다. 
객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다.<br/>

프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름, 즉 자바스크립트에서 사용 가능한 유효한 이름이 아니면 반드시 대괄호 표기법을 사용해야 한다. 
단, 프로퍼티 키가 숫자로 이뤄진 문자열인 경우 따옴표를 생략할 수 있다. 
그 외의 경우 대괄호 내에 들어가는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다는 점을 잊지 말자.<br/>

delete 연산자는 객체의 프로퍼치를 삭제한다. 
이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 
만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러 없이 무시된다.<br/>

ES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다. 
이 때 프로퍼티 키는 변수 이름으로 자동 생성된다.

```js
let x = 1, y = 2;
const obj = { x, y };
console.log(obj); // { x: 1, y: 2 }
```

### 11장. 원시 값과 객체의 비교 (2022.10.31)

원시 타입과 객체 타입은 크게 세 가지 측면에서 다르다.

- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 이에 비해 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값이다.
- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 다시 말해, 한번 생성된 원시 값은 읽기 전용값으로서 변경할 수 없다.
변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.
즉, "원시 값은 변경 불가능하다"는 말은 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다. 
변수는 언제든지 재할당을 통해 변수 값을 변경(엄밀히 말하자면 교체)할 수 있다. 
그렇기 때문에 변수라고 부른다.<br/>

문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

`유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할 수 도 있다.`

"값에 의한 전달도"도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 
단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.<br/>

`자바크스립트 객체는 프로퍼티 키를 인덱스를 사용하는 해시 테이블(해시 테이블은 연관 배열, map, dictionary, lookup table이라 부르기도 한다)이라고 생각할 수 있다. 대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현한다.`

원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 
하지만 객체는 변경 가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 
즉, 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.<br/>

얕은 복사와 깊은 복사
- 객체를 프로퍼티 값으로 갖는 객체의 경우 얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.
- 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다. 즉, 원본과 복사본은 참조 값이 다른 별개의 객체다. 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.

결국 "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달하는 면에서 동일하다. 
다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다. 
따라서 자바스크립트에는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만 존재한다고 말할 수 있다.

### 12장. 함수 (2022.11.01)

리터럴은 값을 생성하기 위한 표기법이다. 
따라서 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다. 
즉, 함수는 객체다.<br/>

함수는 객체지만 일반 객체와는 다르다. 
일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 
그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.<br/>

`변수는 '선언'한다고 했지만 함수는 '정의'한다고 표현했다. 
함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 
따라서 ECMAScript 사양에서도 변수에는 선언, 함수에는 정의라고 표현한다.`

