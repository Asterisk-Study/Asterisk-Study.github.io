---
title: "윤태연 독서일지: 모던 자바스크립트 Deep Dive"
layout: post
comments: true
categories: [윤태연/독서일지]
tags: 윤태연
---

<span style="color:rgba(57, 62, 70, .5)">2022-11-08</span> <br />

모던 자바스크립트 Deep Dive
1000페이지 가량 돼서 오개안말처럼 단원마다 읽고 기록을 하면 지쳐 죽는다. 읽고 목차에 날짜와 페이지쓰고 내용을 정리하는 식으로 하자.
잘모르겠으면 [유튜브 스터디 공부 영상](https://www.youtube.com/watch?v=3ZP3VPlrr0U)랑 같이 보자!

# 들어가며

---

JS는 편리한 언어고 프론트, 백을 아우르는 범용 언어가 돼 그에 맞는 학습법과 깊이 있게 배우고 싶은 독자들에게 바친다. 왜냐면 JS 특성상 유연해 잘못하면 코드의 의사소통이 쉽게 어려워질 수 있는 언어기 때문이다. 또 JS의 실력 피라미드가 있다면 가장 받쳐주는 하위 블록은 개념과 동작 원리 이해에 기반한다. 그래서 조금 숙달됐더라도 이 책을 읽으면 더 수월하게 구현 가능하다. 또한 이 책을 읽으며 무엇을 알고 무엇을 모르는지 깨닫고 시행착오에 직면해도 이 책으로 도움 받아 결국 구현, 프로젝트를 만드는 데 도움이 됐음 좋겠다. 결국 이해(동작 원리)-숙달(코딩 스킬 연마)-프로젝트(구현, 경험)의 발판을 갖는, 이해의 반경을 점진적으로 넓혀가는 지속적 개선을 꿈꿔보자.

<span style="color:rgba(57, 62, 70, .5)">2022-11-09</span> <br />

# 01장. 프로그래밍

---

사용자와 컴퓨터 간의 커뮤니케이션. 왜? 주어진 문제를 해결하기 위해! 어떻게? 컴퓨팅 사고(CT)를 통해 기계에게 보다 정확하고 상세하게 작성. 기계어를 사람이 알기 힘들기에 컴파일러를 통해 상호작용, 그래서 그 컴파일러에 맞게 작성해야한다. 즉, 문법(Syntax)과 의미(Semantics)에 맞춰서 작성하자! <br />
결론: 요구사항의 집합을 분석, 적절한 자료구조와 함수의 집합으로 변환 한 후, 그 흐름을 제어

<span style="color:rgba(57, 62, 70, .5)">2022-11-12</span> <br />

# 02장. 자바스크립트란?

---

- 역사<br />JS는 기본 웹페이지에 기능을 추가하고 싶어 가벼운 언어로 브렌던 아이크가 개발했다. 마소의 방해로 인한 크로스브라우징으로 입지가 어려워지자 JS는 ECMAScript라는 표준 사양을 공개해 표준 언어로 입지를 갖춰갔고 2015년 ES6가 나오면서 포텐을 터뜨린다. <br />
- JS 성장의 발판<br />
  - Ajax: XMLHttpRequest라는 이름으로 출시해 비동기적으로 데이터 호출, 펫칭(비동기)
  - jQuery: DOM 쉽게 제어 가능 + 배우기 쉬움, 크로스브라우징 이슈 약간 해소
  - V8 엔진: 더더욱 빠르게 동작하는 엔진 장착, 사이트가 앱으로 생각들만큼 속도-UX 향상, 클라에서 로직이 수행돼 프론트엔드 분야가 대두
  - Node.js: 브라우저 이외의 환경에서 JS를 구동시킬 수 있게 됨, 서버-클라 두가지 영역에서 같은 언어를 써 더욱 성장하게 된 계기가 됨
  - SPA: 그 전 방식으로는 MPA로는 개발하기도 어렵고 관리하기도 어려워졌다. 그로 인해 프렘웤, 라이브러리가 나왔다. 리액트, 뷰, 스벨트 등등
- 특징 <br />웹브라우저에서 동작하는 유일한 언어, 별도로 컴파일 작업을 안해도 되는 '인터프리터' 언어, 멀티 패러다임 프로그래밍 언어(명령형, 함수형, ⭐️프로토타입 기반 객체지향 프로그래밍)

### 03장은 건너뜀

브라우저 동작, 크롬 개발자 도구 알려줌, node.js 실행법, VSC 뭐 이런거..

<span style="color:rgba(57, 62, 70, .5)">2022-11-17</span> <br />

# 04장. 변수

---

코드를 보고 계산하기 위해 CPU는 연산하고 메모리를 사용해 데이터를 기억, 10 + 20 해도 10과 20은 임시적으로 메모리 셀에 저장돼 CPU에서 읽어와 연산됨.<br />

<p>만약 연산 결과값을 사용할 때마다 임시 메모리에 넣어줄 30을 제어하든가 10 + 20을 써야한다. 하지만 JS는 치명적 오류 가능성으로 개발자의 직접적 메모리 제어를 허용하지않는다. 즉! 변수는 '하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름'을 뜻한다. 걍 기억하고 싶은 걸 변수라는 단어에 저장하고 읽어 재사용할 수 있는 메커니즘이다.(여러 값을 원한다면 '참조 데이터'를 써야한다.) '변수이름 = 변수값'으로 이뤄져 있고 변수를 만들 땐 '선언', 값을 지정할 땐 '할당'</p>
<p>변수 이름을 '식별자'라고도 부름, 값을 구별할 식별자! 그리고 '식별자'는 직접적 값이 아닌 '메모리 주소'를 기억한다. 메모리 공간에 접근할 수 있는 이름이기에. 변수 뿐만 아니라 함수, 클래스 등에 쓰인다.</p>
<p>변수의 선언은 `var`, `let`, `const`키워드를 사용해 선언한다. 스코프 관련 전역 변수 충돌 문제로 ES6에 `let`, `const` 키워드가 들어왔다.<br />
과정: '`var` 이름'하면 JS의 '실행 컨텍스트'에 등록돼 '선언단계'가 수행되고(JS엔진에 변수 존재 알림) 0x00000000~0xFFFFFFFF 사이 메모리 주소 중 하나에 공간을 확보한 후 값이 없다면 `undefined` 할당, 초기화(선언 이후 최초로 값 할당)하는 '초기화 단계'가 수행된다. 초기화는 이전 메모리에 값이 있을 수 있어 말 그대로 메모리를 '초기화'를 해준다. 선언이 없다면 참조할 수 없다며 'ReferenceError'가 뜬다. 
</p>

<span style="color:rgba(57, 62, 70, .5)">2022-11-19</span> <br />

<p>변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS의 고유의 특징을 변수 호이스팅이라 한다. 그래서 '호이스팅'이 일어난다. JS는 인터프리터로 인해 위에서 아래로 순차적으로 실행되는 특성이 있지만 그 전 평가 과정을 거쳐 코드 실행 준비를 한다. 여기서 그런 과정을 거치며 먼저 선언 키워드를 사용해 선언하는 모든 식별자는 이때 실행돼 선언된다! 함수, 변수 등 모두 런타임 이전 단계에 실행되기 때문!</p>
<p>여기서 연산자 '='를 써서 변수에 값을 지정하는 '할당' 개념도 나오는데, 값의 '할당'은 실행 포인트가 다르다. '선언'은 런타임 이전에 실행돼 선언되지만 '할당'은 코드가 순차적으로 실행되는 런타임에 실행된다! 이 점 유의하자.</p>
<p>선언되고 나서 '=' 연산자를 사용해 값을 변경하는 '재할당'도 가능하다. 하지만 `const`로 선언된 변수 같이 값을 변하지 못한다면 '상수'(Constant)라고 한다.</p>
<p>재할당 후 메모리에 저장된 값들을 메모리 누수 방지를 위해 '가비지 콜렉터'가 없애준다. 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. 즉, JS는 관리되는 언어로 '매니지드 언어'라고 칭한다.</p>

<span style="color:rgba(57, 62, 70, .5)">2022-11-20</span> <br />

# 05장. 표현식과 문

---

<p>그동안 나왔던 '값'이라는 표현은 정확히 얘기하자면 '(표현)식이 평가돼 생성되거나 참조된 결과물'이라 정의할 수 있다. 여기서 식을 쓰려면 어떤 표현을 따르는 것의 답은 바로 '리터럴'이다.<br />
'리터럴'은 사람이 이해할 수 있는 문자 또는 미리 약속된 기호로 표기한 코드를 뜻한다. 우리가 쓰는 정수(8, -1 등), 부동점(.5), 문자열(""), null, undefined, 참조({}, [], 함수), 정규 표현식(미리 약속된) 등이 있다. 만약 리터럴로 8을 썼다면 그것은 그 자체의 값으로 전달하는 게 아닌 아라비아 숫자 '8'로 JS 엔진에게 전달하고 엔진은 값 자체인 숫자 '8'로 인식해 저장하는 식이다.<br />
이제 알겠지만 리터럴로 이루어져 식을 이뤘고, 평가돼 값을 생성하는 것을 '표현식'(Expression)이라고 칭한다. 정리하자면 리터럴과 표현식은 거의 같다고 보면 되고, 그러한 '표현식'이 모여 '문'이 된다.</p>
<p>'문'(Statement)은 프로그램을 구성하는 기본 단위, 최소 실행 단위이다. 문을 보통 명령문이라 생각하면 된다. 컴퓨터에게 선언, 할당, 조건, 반복하라고 명령할 수 있는 것이다. 또 문을 이루는 구성요소들을 ⭐️'토큰'이라 부른다.</p>
정리하자면 만약 변수에 어떤 문인 코드를 작성해 할당할 때 표현식인 문은 값으로 평가돼 할당 가능하지만 표현식이 없는 문은 할당하지 못해 undefined가 뜬다.

<span style="color:rgba(57, 62, 70, .5)">2022-11-23</span> <br />

# 06장. 데이터 타입

---

<p>JS의 모든 값은 데이터 '타입'을 가진다. 숫자, 문자열, 불리언, unde, null, 심벌을 가진 원시 타입과 객체, 배열, 함수 등을 가진 객체 타입이다.<br />
어째서 타입 별로 잘 구분하여 작성해야할까? 여러 이유가 있는데

1. JS 엔진은 값을 읽어와 메모리 공간에 저장하는데 타입 별로 메모리 낭비와 손실 없게 정해진 바이트 수를 확보해야한다.
2. 엔진은 값을 참조하는데 한번에 읽어들일 메모리 공간의 크기(메모리 셀 개수-바이트 수)를 알아 값이 훼손되지 않게 해야한다.
3. 엔진은 값을 2진수로 저장하고 읽어들인다. 여기서 타입 별로 읽어들이는 2진수의 해석이 달라진다.

이러한 JS의 특징으로 타입을 제대로 구분해 로직을 작성해야한다.</p>

<p>또한 JS만의 변수 특징으로 타입을 더 구분해야하는데 이유는 JS는 '동적 타입 언어'이기 때문이다. 동적 타입 언어란 변수가 선언에서 타입을 정하는 것이 아닌 값을 할당하고 값의 타입에 따라 변수의 타입도 결정되고, 재할당으로 인해 ⭐️언제든지 타입이 변할 수 있는 언어라는 뜻이다. <br />
반대인 '정적 타입 언어'는 C, Java, Kotlin, Go 등의 언어들을 칭하고 변수 선언할 때 char, int 등으로 타입을 정해 컴파일하면서 '타입 체크'하는 언어이다.<br />
이러한 특징으로 JS는 타입에 대해 '유연함'을 가지고 있지만 버그가 자주 발생할 수 있어 '신뢰성'이 떨어진다. 그래서 JS의 이런 모습을 싫어하는 사람도 여럿 있다. JS는 특히 타입이 여러번 변하니 코드를 작성하거나 디버깅을 할 때는 변수 타입을 예상해 버그를 방지하고 변수 네이밍을 철저히 해 가독성을 올리는 쪽으로 버그, 오해가 생기지 않도록 한다.</p>

<span style="color:rgba(57, 62, 70, .5)">2022-11-26</span> <br />

# 07장. 연산자

---

먼저 알아둬야할 게 연산자로 연산하는데 숫자가 아닌 falsy, truthy 값들로 있어서는 falsy는 0으로, truthy는 1로 '암묵적 타입 변환'된다.

<p>연산자는 피연산자인 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산 등을 수행해 하나의 값을 만드는 귀여운 놈이다.
- 산술: 이항 산술 연산자-사칙연산과 나머지를 구하는 기호(`+`,`-`,`*`,`/`,`%`), 단항 산술 연산자(`++`, `--` 등), 문자열 연결(`+`)
- 할당: 기본적인 등호(`=`) 말고도 산술 연산자를 붙인 `+=`, `-=`, `/=` 등을 붙여서 `x += y` 면은 `x = x + y`로 치환된다. 산술보다 더 편하게 가능!
- 비교: `==`, `===`, `!=`, `!==`, 짧은 것들은 암묵적 타입 변환되니까 예측하기 어려움, 버그 안일으키고 싶으면 긴 거 쓰자. 주의할 것은 `NaN`은 자신과 일치하지 않는다. 조심!
- 대소 관계: `>`, `<` 등, 불리언 값을 반환한다!
- 삼항 조건: `~ ? ~ : ~`, 일반적인 if문과 다르게 삼항 조건 연산자는 값처럼 사용할 수 있다. 즉, 변수에 할당이 가능하다는 얘기
- 논리: `||`, `&&`, `!`, `!!`, 알아둬야할 건 ! 부정 연산자를 2번 쓰면 암묵적 타입 변환이 일어나 불리언 반환하는 조건문처럼 쓸 수 있다.
그 외 쉼표 연산자(`,`), 그룹 연산자(`()`), `typeof` 연산자, 제곱(`Math.pow`)이 가능한 지수 연산자(`**`), 객체 프로퍼티를 삭제하는 `delete`, new, in 등이 있다.</p>
<p>대부분 연산자는 다른 코드에 영향 X, 하지만 영향을 주는 연산자가 있는데 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자이고, 이를 부수 효과가 일어난다고 표현한다.<br />
연산자에는 우선순위가 있는데 16위 까지 있어서 외우긴 힘들고 그냥 소괄호 쓰는 그룹 연산자가 짱니니 그걸로 명시적인 조절을 꾀하자.</p>
