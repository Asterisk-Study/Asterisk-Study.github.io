---
layout: single
title: "이유정 독서일지(3장): 메모리와 디스크의 핵심: 순차 논리"
categories: 독서일지
tags: 이유정
---
2022년 11월 07일 월요일 ~ 11월 13일 일요일 p.135 - p. 163

# 3장 메모리와 디스크의 핵심: 순차 논리 
- 컴퓨터는 비트를 어떻게 기억하는가 
조합논리는 입력에 의해서만 출력이 결정된다. 이번 장에서는 순차 논리를 배운다. 디지털 회로에서 시간을 어떻게든 만들어내야 한다.  
조합 논리는 입력의 현재 상태만 다룬다. 하지만 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려한다. 
이번 장에서는 시간을 만들어내는 회로와 과거를 기어ㅓㄱ하기 위한 회로에 대해 배운다.  
## 시간 표현과 상태 기억 
컴퓨터의 경우 전자공ㅇ학을 사용하기 때문에 주기적인 전기 신호가 필요하다. 
### 발진자 
정확한 발진자를 적은 비용으로 효율적으로 만드는 방법은 크리스털을 활용하는 것이다. 자석과 마찬가지로 크리스털도 전기와 관련있다. 
전극을 크리스털에 연결하고 크리스털을 압축하면 크리스털이 전기를 만들어낸다. 그리고 전극에 전기를 가하면 크리스털이 구부러진다. 이런 현상을 피에조 전기 효과라고 부른다. 
크리스털은 음성 진동을 잡아낼 수 있어서 마이크 만들 때 이를 쓸 수 있다. 크리스털에 전기를 가해서 음성진동을 만들어낼 수 있어 전기 기구에서 다양한 경보음을 낼 수 있다. 
크리스털 발진자는 전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻어낸다. 입력한 전기로부터 크리스털이 전기를 다시 만들어내느 시간이 예측이 가능하며 매우 정확하다. 
### 클록
발진자는 컴퓨터에 클록을 제공한다. 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정된다. 비닝 과정은 부품을 측정해서 그 특성에 따라 여러 다른 빈이나 무더기로 분류한다.
컴퓨터를 오버클로킹한다. 통계적으로 빈의 중간 정도에 위치하는 부품을 부품이 고장 나지 않을 범위 안에서 클록을 빠르게 공급하는 도박을 한다는 뜻
### 래치
정보를 1비트 기억할 방법을 생각해보자. or 게이트의 출력을 입력에 묶는 방식의 되먹임을 사용하면 정보를 기억할 수 있다. or 게이트의 출력을 입력에 묶는 방식의 되먹임을 사용하면 정보를 기억할 수 있다.
이 회로는 자신의 과거 상태를 기억한다. 이 회로만으로는 out을 다시 0으로 만들 방법이 없기 대문에 되먹임을 끊고 회로를 재설정할 방법이 필요하다. 
두 입력이 모두 동시에 거직으로 바뀌는 경우에는 전파 지연 시간에 따라 출력이 달라지기 때문에 결과를 예측할 수 없다. 
### 게이트가 있는 래치
s와 r 게이트의 입력이 모두 1이기 때문에 출력이 그대로 유지된다. 인버터를 추가해서 입력을 1비트만 받게 만든다. 게이트를 여는 시간을 최소화해서 거의 순간적으로 D의 상태에 맞춰 출력 상태를 변경할 수 있게 한다면 좋을 것이다. 
### 플립플롭
데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화하고 싶다. 논리수준이 특정 값에 머무는 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것이다. 
이런 전이를 에지라고 부른다. 논리 수준 사이의 전이가 거의 순식간에 벌어진다. 에지에 의해 데이터 변화가 촉발되는 래치를 플립플롭이라고 부른다. 
### 카운터
시간을 셀수 있다. 
플립플롭을 응용한 회로 중에는 1,2,3 순서대로 수를 세는 카운터가 있다. 비동기 카운터라고 부르기도 한다. 
타이밍 다이어그램은 전파지연을 제대로 감안해 3비트 수를 세는 경우를 보여준다. 하지만 오른쪽 그림은 전파 지연이 허용하는 것보다 더 빠른 속도로 입력을 변화시키는 경우를 보여준다. 
이 경우 출력이 틀리는 경우가 생긴다. 동기적 카운터를 설계해서 리플 카운터의 타이밍 문제도 해결할 수 있다. 
### 레지스터
더 많은 정보를 저장하는 법을 알려줄게
가산기 출력을 클록을 사용해 레지스터에 넣고 나면, 가산기의 입력을 바꿔도 결과는 바뀌지 않는다. 
- - -

## 메모리 조직과 주소 지정
비트를 하나 기억할 때 플립플롭이 유용하고, 레지스터를 사용하면 쉽게 비트를 저장할 수 있다. 하지만 훨씬 더많은 정보를 저장할 땐? 
메모리 칩도 내부에서는 격자로 관리된다. CPU 사진을 보면 메모리 덩어리로 이뤄진 직사각형 영역을 볼 수 있다. 
주소를 행과 열의 두 덩어리로 나눈다. 메모리 내부 위치는 열과 행을 조합해 지정된다. 훨씬 더 많은 메모리가 있다면 어떨까? 
행과 열 주소를 멀티플렉싱하면 주소 라인의 수를 반으로 줄일 수 있다. 이런 식의 절약을 위해 추가로 필요한 것은 멀티플렉싱한 주소를 저장하기 위한 레지스터 뿐이다. 

### 임의 접근 메모리 
임의 접근 메모리는 RAM이라고 부른다. RAM을 사용하면 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다. 
SRAM 은 비싸지만 아주 빠르다. 
DRAM은 커패시터 라는 아주 작은 버킷에 전자를 담고, 트랜지스터를 1개만 사용해 뚜껑을 덮는다. 문제는 이 버킷이 새기 대문에 가끔 메모리를 갱신해야 한다. 
DRAM은 집적도가 높기 대문에 큰 메모리 칩에 사용된다. 
SRAM이나 DRAM은 모두 휘발성 메모리다. 전원이 끊어지면 데이터가 사라진다는 뜻 
코어 메모리는 오래된 비휘발성 RAM으로 비트를 토러스 모양의 쇳조각에 저장한다. 코어는 아주 오래된 기술이지만 비휘발성은 여전히 가치가 있다. 그래서 요즘도 코어 메모리와 RAM의 장점을 합친 실용적인 자기저항성 메모리를 개
개발하기 위한 연구가 이뤄지고 있다.
### 읽기 전용 메모리
ROM은 그리 정확한 이름은 아니다. 한번만 쓸 수 있는 메모리라고 불러야 한다. ROM은 한번 쓰고 나면 여러 번 읽을 수 있다. 
IBM카드와 종이 테이프는 순차적 메모리다. 데이터를 일정한 순서로만 읽을 수 있다는 뜻이다. 
마스크는 집적 회로 생산 과정에서 사용하는 공판화를 뜻한다. 
PROM은 단 한 번만 ROM에 프로그램을 적어ㅓ 넣을 수 있다. PROM은 오류 등으로 버려진 프롬이 산처럼 쌓이기 위웠다. 따라서 
지울 수 있는 읽기 전용 메모리 EPROM이 등장! 패키지 위쪽에 수정 창이 있어서 특별한 자외선 빛 아래 EPROM을 넣어두면 저장된 내용을 지울 수 있었다 
EEPROM은 전기로 지울 수 있는 EPROM이다. 수정 창도 필요없고 자외선도 필요없다. 내부 데이터를 아무 순서로나 쓰고 읽을 수 있다. 
- - -

## 블록 장치 
메모리를 읽거나 쓰려면 시간이 걸린다. 대량 저장장치로 알려진 디스크 드라이브는 엄청나게 많은 데이터를 저장한다. 디스크 헤드가 우리의 손 역할을 한다. 
디스크 드라이브는 디스크의 영역을 자화시켜서 데이터를 저장한다. 이로 인해 디스크 드라이브는 코어 메모리와 마찬가지로 비휘발성이다. 
디스크 드라이브는 기록 밀도와 속도를 맞바꾼 기억장치다. 디스크 드라이브는 헤드 아래 원하는 비트가 돌아올 때깢 시간이 걸리기 때문에 속도가 느리다. 
하지만 DRAM등과 달리 주소나 데이터 연결을 위한 공간이 필요없다.
디스크는 바이트 단위로 주소를 지정해 읽는 대신 블록 단위로 주소를 지정해 읽는다. 
블록은 역사적으로 섹터라고 불려왔고, 디스크에서 읽고 쓰기가 가능한 가장 작은 단위다. 디스크에서 한 바이트만 바꾸고 싶으면 전체 블록을 읽고 원하는 바이트를 바꾼 다음 전체 블록을 다시 써야 한다ㅎ
하드 디스크에는 레이아웃이 이뤄진 원판이 하나 이상 회전축에 연결되어 돌아간다. 
탐색 시간은 헤드를 한 트랙에서 다른 트랙으로 옮길 때 걸리는 시간이다. 탐색 시간에 더해서 원하는 데이터가 헤드 아래로 올 때까지 디스크가 돌아야 하는데 이때 걸리는 시간을 회전 지연 시간이라고 부른다. 
디스크 드라이브를 종종 하드 드라이브 라고 부른다. 
광학 디스크는 자기 디스크와 비슷하지ㅏㄴ 데이터를 읽고 쓰기 위해 자성 대신 빛은 사용한다는 차이가 있다. 
같은 데이터를 포함하는 디스크를 대량으로 찍어낼 수 있다.

## 플래시 메모리와 ssd유
플래시 메모리는 가장 최근 나타난 EEPROM 유형의 매체다. 플래시 메모리는 DRAM과 마찬가지로 버킷에 전자를 담는 방식으로 작동한다. 하지만 플래시 메모리의 버킷은 dram보다 크고 잘 만들어져 있어서 전자가 새지 않는다 
플래시 메모리는 읽을 때는 임의 접근 장치이고 쓸 때는 블록 접근 장치다. 
디스크 드라이브는 점차 SSD로 널리 알려진 고체 상태 드라이브로 교체되고 있다. SSD는 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같다. 

## 오류 감지와 정정
복사본을 2개 더 만들어 세 데이터를 비교해서 둘 이상 일치하는 쪽이 맞는다고 하자. 패리티를 사용하면 단 1비트만 데이터가 잘못된 경우를 감지할 수 있다. 
해밍코드는 더 많ㄷ은 비트를 사용해 더 많은 오류를 감지할 수 있고 오류 횟수가 작으면 오류가 일어난 부분을 바로 수정할 수도 잇다. 이런 회로를 내장한 오류 검사와 정정 메모리 칩도 잇다. 
패리티 같은 방법은 끊임없이 변화하는 데이터를 처리할 때 유용하다. 
정적인 데이터 블록을 검증하는 더 값싼 방법도 있다. 체크섬 
순환 중복 검사는 수학적으로 체크섬보다 더 나은 대체재다. 이런 방식의 목표는 데이터의 고유성을 충분히 드러낼 수 잇는 방식으로 검증 숫자를 계산해서, 
데이터가 약간이라도 바뀌면 검증 숫자가 더이상 일치하지 않게 만드는 것이다. 

## 하드웨어와 소프트웨어 비교 
PROM, EEPROM, 플래시 메모리 등을 만들 대 사용한 기술은 메모리에 한정되지 않는다. 
펌웨어는 RPM에 담긴 소프트웨어를 가리키는 용어였다. 
집적회로는 제작 비용이 ㅁ낳이 든다. 초반에 모든 칩 설꼐는 완전한 커스텀설계였다. 칩은 여러 계층으로 만들어지며, 맨 아래에 실제 구성요소가 들어가고 그 위에 각 
구성요소를 이어주는 선들이 들어갔다. 게이트 배열은 몇몇 응용에서 칩 제작 비용을 줄이기 위한 노력이었다.
게이트 배열에는 미리 설계된 구성요소가 존재하고 오직 금속 계층만 커스텀화할 수 있다. 메모리와 마찬가지로 게이트 배열도 PROM 에 해당하는 직접 프로그래밍 할 수 있는 칩으로 변화했다.
현대적 FPGA는 플래시 메모리에 해당하는 논리 칩이다. 
FPGA는 플래시 메모리에 해당하는 논리 
