---
title: "이유정 독서일지(4장): 컴퓨터 내부 구조"
layout: post
comments: true
categories: [이유정/독서일지]
tags: []
---
컴퓨터 하드웨어는 어떻게 구성되는가? 
현대적 컴퓨터는 크게 메모리, 입력과 출력, CPU라는 세가지 부분으로 나눌 수 있다. 
이번 장에선 CPU에 대해 알아보자 
## 메모리 
메모리: 컴퓨터에는 조작할 비트들을 저장할 장소가 필요하다. 
컴퓨터가 메모리를 어떻게 사용하는가? 
메모리는 집이 빈틈없이 늘어선 거리와 같다. 컴퓨터를 만드는 규칙에는 각 집마다 1바이트를 저장한다고 되어있다. 각 집에는 주소가 부여된다. 
다양한 메모리가 있는데, 각 메모리는 가격, 성능 비율이 다르다. SRAM은 빠르고 비싸지만 디스크는 저렴하지만 느리다. 
인텔 프로세서는 0번 바이트가 가장 오른쪽에 가고, 모토로라 프로세서는 0번 바이트가 가장 왼쪽에 간다. 이런 엔디안 배열을 염두에 둬야 한다. 한 시스템에서 다른 시스템으로 데이터를 전송 할 때 엔디안을 무시하면 데이터 순서가 뒤섞일 수 있다. 
## 입력과 출력 
I/O 에 연결되는 장치를 주변장치라고 부르며, 영어로는 퍼리퍼럴 이라고 한다. 
이제는 메모리 거리 중 일부를 I/O 장치에 할당하는 것이 더 타당해졌다. 
많은 컴퓨터에는 설계상 표준 입력/출력 슬롯이 있어서 일관된 방식으로 I/O 장치를 연결할 수 있다. 

## 중앙 처리 장치
CPU는 실제 계산을 처리하는 컴퓨터 부품이다. 
### 산술 논리 장치 
ALU는 CPU의 핵심 부품이다. 수를 표현하는 비트인 피연산자와 연산 코드 , 즉 명령코드는 피연산자에 대해 ALU가 어떤 연산자를 적용할지 지정한다. 결과는 물론 피연산자에 연산자들을 적용한 결과를 뜻한다. 조건코드에는 결과에 대한 추가 정보가 들어간다. 보통 조건 코드레지스터라는 레지스터에 조건 코드가 저장된다. ALU는 실제로는 앞에서 배운 실렉터와 논리 게이트를 연결한 것일 뿐이다. 
### 시프트 
왼쪽 시프트는 어떤 숫자의 모든 비트를 왼쪽으로 1비트씩 옮기고, 맨 왼쪽 비트는 버리고 가장 오른쪽 비트에 0을 넣는다. 왼쪽 시프트를 할 대 사라지는 MSB값이나 오른쪽 시프트를 할 대 사라지는 LSB 값이 필요할 때가 종종 있다. 그래서 이 비트를 조건 레지스터에 저장한다. 왼쪽 시프트는 어떤 수를 2로 곱해도 같다는 점에 착안해, 배럴 시프트와 가산기를 조합하는 조합논리 곱셈기를 만들 수 있다. 시프트는 부동소수점 연산을 구현할 때도 핵심 부품이다. 
### 실행장치
실행장치는 제어장치라고도 알려져 있다. ALU는 그 자체로만 유용하지 않고, 누군가 ALU에게 할 일을 알려줘야 한다. 실행장치는 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다. 
우리는 실행장치에게 명령어 목록을 제공한다. 실행장치는 이 명령어를 메모리에서 찾는다. 명령어는 컴퓨터에게 어떤 일을 할지 알려주는 비트패턴이다. 실행장치는 메모리에서 명령어를 가져와야 하는 위치를 프로그램 카운터를 통해 안다. 프로그램 카운터에는 메모리 위치를 가리키는 주소가 있다. 

## 명령어 집합 
### 명령어 
DRAM 주소 지정 기법을 활영해 주소 확장 레지스터를 두고 별도의 명령어를 사용해 상위 주소를 지정한다. 3주소 명령어가 잘 작동하지 않는 중요한 이유는, 세가지 메모리 위치를 한꺼번에 지정하는 메모리 주소 접근을 사용한다. 세 메모리 블록은 각기 다른 장치에 존재하며 주소 버스와 데이터 버스가 3개씩 따로 존재한다. 이런 경우 연산 결과를 다른 연산에 활용하려면 결과가 들어 있는 메모리 장치에 있는 데이터를 다른 피연산자 메모리 장치로 보내기 위한 별도의 명령어를 사용해야 한다. 그리고 cpu 패키지의 입출력 핀 수가 제한되어 있기 때문에 cpu 패키지를 늘리고 핀 개수를 늘리지 않으려면 세 버스가 같은 핀을 공유하고 다른 클록에 작동하는 수밖에 없다. 하지만 이런 식으로 처리하려면 버스를 3벌이나 둘 이유가 없다. 따라서 데이터 버스와 주소 버스를 하나만 두고 메모리 장치를 공유해야 한다. 
누산기는 ALU가 계산한 결과를 저장한다. 우리는 두 메모리 위치에 있는 값 사이에 연산을 수행해서 결과를 다른 메모리에 넣는대신, 한 메모리 위치에 있는 값과 누산기에 있는 값에 대해 연산을 수행하고 결과를 누산기에 넣는다. 물론 누산기에 있는 값을 메모리에 저장하기 위한 저장 명령어를 추가해야 한다. 
### 주소 지정 모드 
#### 직접 주소 지정
누산기를 사용하면 12비트를 주소 지정에 쓸 수 있고, 4096가지 주소를 가리킬 수 있으면 16가지 주소를 가리킬 수 있는 것보다는 훨씬 낫지만, 여전히 사용가능한 주소가 충분하지 않다. 즉, 사용할 주소가 명령어에 직접 들어가 있는 방식
#### 간접 주소 지정
더 많은 메모리를 사용할 수 있는 방식이다. 간접 주소 지정 방식에서 CPU는 명령어에 있는 값을 피연산 주소로 해석하지 않고, 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용한다. 
#### 즉시 주소 지정 모드
위, 두가지 주소 지정 모드만으로도 메모리를 다루기는 충분하지만 때로 상수를 지정해야 할 때가 있다. 
### 조건 코드 명령어
조건코드를 다루는 명령어는, 조건 코드를 원하는 값으로 설정하고나, 조건 코드의 값을 살펴볼 수 있는 방법이 필요하다. 조건 코드 레지스터의 값을 누산기로 복사하는 cca라는 명령어와 누산기의 값을 조건 코드 레지스터에 복사하는 acc 라는 명령어를 추가할 수 있다. 
### 분기 명령어 
의사결정을 내리고 코드 중 일부를 선택적으로 실행할 수 있는 프로그램이 있으면 좋을 것 같다. 프로그램 카운터의 값을 변경할 수 있는 명령어, 분기 명령어가 해결책이다! 조건 코드를 살펴보고 어떤 조건을 만족할 때만 분기하는 명령어도 있다. 이런 분기 명령어에는 조건을 저장하기 위한 비트가 필요하다. 때로는 프로그램 카운터의 내용을 명시적으로 바꿀 필요가 있다. 이를 위한 두 가지 특별한 명령어가 있다. pca는 현재 프로그램 카운터 값을 누산기에 복사하고, apc는 누산기의 값을 프로그램 카운터에 복사한다. 
### 최종 명령어 집합 구성
주소 지정 모드는 세가지가 있다. 따라서 주소 지정 모드 선택을 위해 2비트가 필요하다. 앞에서 다룬 세 가지 주소 지정 모드 외의 네 번째 모드는 메모리와 관계없는 연산을 표현한다. 주소 지정 모드와 명령코드를 디코딩하면 명령어를 얻을 수 있다. 분기 명령어를 명령코드에 추가했다는 점을 유의하자. 주소 지정 모드 3의 명령코드는 누산기와만 관련된 명령어를 표현하기 위해 사용된다. 
명령어를 세 필드로 구분했다. 설명에 있는 모든 주솟값은 10진수이고, 주소와 명령어에 있는 숫자는 모두 이진수다. 
## 마지막 설계 
지금까지 살펴본 모든 부분을 하나로 모아서 실제 컴퓨터로 만들어보자. 여러 부분이 함께 작동하려면 일종의 접착제에 해당하는 요소가 필요하다. 
### 명령어 레지스터 
컴퓨터에서 벌어지는 일을 두 단계로 이뤄진 상태 기계로 설명할 수 있다. 처음에 컴퓨터가 해야할 일은 메모리에서 명령어를 가져오는 페치다. 명령어를 실행하려면 메모리에 접근해야 할 경우가 많다. 이 말은 다른 목적으로 메모리를 사용할 때 페치한 명령어에 편하게 접근할 수 있도록 저장할 다른 위치가 필요하다는 뜻이다. CPU에 명령어 레지스터를 추가해서 현재 실행 중인 명령어를 저장한다. 
### 데이터 경로와 제어 신호
프로그램 카운터의 값을 메모리 주소 버스에 넣을 방법과 메모리에 잇는 데이터를 명령어 레지스터로 넣을 방법이 필요하다. 
주소 실렉터는 단지 3방향 교차로일 뿐이고, 데이터 실렉터는 4방향 교차로다. 
간접 주소 레지스터가 필요한 이뉴는 간접 주소 지정을 사용할 때 메모리에서 읽어온 주소를 어딘가에 저장해야 하기 때문이다. 이는 명령어 레지스터에 메모리에서 읽어온 명령어를 저장하는 것과 비슷하다. 
레지스터에도 다음 클록 틱에 데이터가 저장된다고 가정하라. 마찬가지로 프로그램 카운터와 메모리도 제어 신호가 지시하는 동작을 클록이 틱에 맞춰 수행한다. 

### 데이터 흐름 제어 
입력과 출력에 대해 알았으므로, 이제 교통을 제어하는 장치를 만들어보자. 
페치와 실행에 여러 단계가 필요하므로 각 단계를 추적한 카운터가 필요하다. 이 카운터의 내용과 명령어의 명령코드와 모드 부분이 제어 신호를 결정한다. 가장 복잡한 연산의 경ㅇ우 3단계가 필요하기 때문에 카운터는 2비트 카운터여야 한다. 또 다른 방법으로 교통 제어 장치를 구현할 수 있다. 
마이크로코드 메모리로 ROM을 쓰면 좋다. 오늘날 쓸 수 있는 마이크로코드를 제공하는 컴퓨터 중에 일반 사용자가 마이크로코드를 변경할 수 있도록 허용하는 경우는 드물다. 
## RISC와 CISC 명령어 집합 
복잡한 명령어를 단순한 명령어를 조합해 처리하는 기계를 RISC라고 부르고, 이를 대조적으로 기존 설계방식으로 만든 컴퓨터를 CISC라고 부른다. 리스크 기계의 중요한 특징으로는 적재-저장 구조를 사용한다는 점이다. 최근의 RISC기계는 오래전의 CISC기계보다 훨씬 더 복잡해졌다. 큰 영향을 끼친 CISC 기계로는 ALU역할을 할 수 있는 범용 레지스터가 8개 있었다. 자동증가 자동감소 주소 지정모드를 지원했다. 
## GPU 
그래픽 처리 장치다. 그래픽은 병렬화하기 아주 좋은 작업이기도 하다. 
GPU를 특징짓는 기능이 두가지가 있다/. 간단한 처리 장치가 아주 많이 들어있다. 두번째로는 GPU는 CPU보다 메모리 버스의 폭이 더 넓다. 이로 인해 메모리에 더 빠르게 접근할 수 있다. GPU도 더 일반적인 용도에 쓰이게 됐다. 여러 가진 표준 프로그래밍 언어로 GPU를 프로그래밍할 수 있게 하는 노력이 진행됐다. 공학계산, 인공지능 등에 GPU를 쓸 수 있다. 
