---
title: "이희진 독서일지(1): 한 권으로 읽는 컴퓨터 구조와 프로그래밍"
layout: post
comments: true
categories: [이희진/독서일지]
tags: []
---

### 221001(1일차) 34p ~ 49p
프로그래밍 언어는 결국 사람이 만들었기 때문에 불완전성(버그)이 존재한다. 이에 대처하기 위함도 있으나 기본적으로 좋은 프로그래밍은 컴퓨터에게 효율적이고 정확하게 명령하는 것이므로 컴퓨터를 이해하는 건 좋은 기반이 된다. 하지만 메모리 관리가 필수였던 C 언어와 달리 메모리 걱정을 하지 않아도 된 자바를 비롯해 비슷한 언어들이 대거 등장하게 된 것은 분명한 발전이나 컴퓨터에 대한 이해를 불필요하게 여겨 프로그래머의 역량을 낮추는 계기가 되었으므로 이에 대한 역량 향상은 필수적이다.  
<br/>

### 221003(2일차) 51p ~ 57p
컴퓨터 언어는 자연어(인간의 언어)와 유사하다. 둘은 기호(문자)가 들어갈 상자, 상자에 들어갈 기호, 상자의 순서로 나눌 수 있는데 컴퓨터 언어에서 이 상자를 비트(2진법 사용을 뜻하는 binary와 숫자를 뜻하는 digit의 합성어)라고 칭한다. 비트 사용법 중 하나로 논리 연산이 있는데 대표적인 게 불리언 대수로, 기본적인 연산자로 NOT, AND, OR, XOR(첫 번째 비트와 두 번째 비트가 서로 다른 값이어야 참)이 있다. 드모르간 법칙(! false === true)을 바탕으로 AND 연산자로 OR을 나타낼 수 있으나 연산자의 사용은 적을수록 효율적이다.  
<br/>

### 221004(3일차) 58p ~ 67p
비트는 2진수로 숫자를 표현할 수 있다. 2의 거듭제곱 단위로 나눈 상자에 나누어 0과 1을 담아 숫자를 표현하며 이때 0과 1의 개수에 따라 비트의 수가 결정된다(e.g. 5,028는 13비트). 가장 오른쪽의(수를 가장 작게 변화시키는 유효) 비트를 LSB, 가장 왼쪽의(가장 크게 변화시키는 유효) 비트를 MSB라 한다. 2진수 또한 덧셈과 뺄셈이 가능하며 비트로 음수를 표현할 땐 '2의 보수'를 사용한다. 이때 '2의 보수'란 양수 2진수에 NOT 연산자를 추가한(0과 1을 반대로 한) 후 1을 더하는 방식을 뜻한다(e.g. 1 = 001 / -1 = 111).  
<br/>

### 221006(4일차) 68p ~ 73p
앞서 말한 숫자 표현은 정수에 한정됐으나 비트로 실수 표현 또한 가능하다. 고정소수점(2의 거듭제곱을 분모로 하는 분수들을 이용해 2진법으로 소수 표현), 부동소수점 표현법 등 다양하게 있으나 해당 방법들의 비효율성(비트의 낭비)을 해결하기 위해 등장한 것이 'IEEE 부동소수점 수 표준'이다. 0.0012를 1.2(가수) x 10(밑)⁻³(지수)로 표현하는 것처럼 밑 2의 지수만 변경해 표현하는 부동소수점에 트릭을 사용해 정밀도를 높인 버전(1. 정규화(가수를 조정해 맨 앞에 0이 없게 만듦), 2. 맨 왼쪽 비트의 1을 생략함)으로 기본 정밀도 부동소수점과 2배 정밀도 부동소수점이 자주 쓰인다.  
<br/>

### 221007(5일차) 74p ~ 78p
2진수의 조작에 있어 불편함을 최소화시키기 위해 사람들은 다양한 표현법을 강구했다. 8진 표현법과 16진 표현법이 그것인데 각각 2진수 비트들을 3개씩, 4개씩 묶어 표현한다. 즉, 11010011111111000001 같은 엄청난 숫자를 4개씩 묶어 (1101/0011/1111/1100/0001) 표현하고 이를 각 진수 표현법의 규칙에 맞춰 변환하면 10몇개의 숫자들이 한 자릿수의 숫자 및 문자로 정리가 된다(예: 1101/0011/1111/1100/0001 => d3fc1). 그렇다면 이런 다양한 표기법을 컴퓨터는 어떻게 구분할까. 구분할 수 있다. 0부터 시작하면 8진수, 1~9 사이의 숫자로 시작하면 10진수, 0x가 앞에 붙으면 16진수다. 이러한 진수 표현에 있어 절대 빠질 수 없는 비트들은 너무 작기 때문에 효율적인 표현을 위해 일정 개수(4, 8, 16 등)로 묶은 덩어리에 이름을 붙여 표현한다(니블, 바이트, 하프워드 등).  
<br/> 

### 221012(6일차) 79p ~ 89p
비트로 수를 표현할 수 있다. 그리고 이 수로 문자를 표현할 수 있다. 아스키 코드는 그 방법 중 하나로 키보드 위 모든 기호에 대해 7비트 수 값을 할당했다. (예: 65는 대문자 A를 뜻함) 키보드 위 문자 외에도 아스키 코드로 아스키 제어 문자 또한 나타낼 수 있다(예: 텍스트 시작, null 등). 또한 영어만 지원했던 기존과 달리 다양한 언어의 표준(유니코드)도 도입하여 문자에 16비트 코드를 부여한다. 하지만 아무리 비트가 저렴해졌다고 해도(이 때문에 기존 7비트에서 16비트까지 증가) 문자 표현에 있어서 8비트면 충분하기 때문에 '유니코드 변환 형식 8비트(UTF-8)'를 아스키가 아닌 문자에 대한 주된 인코딩(다른 비트 패턴 표현을 위해 사용한 비트 패턴) 방법으로 사용할 수 있다. 인코딩의 방식은 다양하고 그 예로 QP(쿼티드 프린터블)인코딩, 베이스64 인코딩, URL 인코딩이 있으며 해당 인코딩들은 기본적으로 문자 8비트 데이터를 송수신 가능한 비트로 쪼개어 인코딩한다. 마지막으로, 수로 색 또한 표현할 수 있다. 컴퓨터는 가산 색 시스템을 바탕으로 한 RGB 모델을 통해 색을 표현한다. RGB은 적, 녹, 청 각각의 진함 정도를 숫자로 표현하며 해당 색에는 각각 8비트가 할당된다. 하지만 여기서 미사용되는 8비트가 존재하는데 이는 색의 투명도를 담당하는 부분이다. 또한 이러한 색은 16진 트리플렛(예: #ffff00은 노란색)을 이용해 각각의 8비트 값을 16진 표기를 통해 두 자리 문자로 바꿔서도 표현할 수 있다.   
<br/>

### 221015(7일차) 91p ~ 97p
비트는 매우 중요하나, 톱니바퀴로 돌아가던 계산기의 시초에 비트는 존재하지 않았고 계산자를 이용한 오트레드의 기계식 계산기와 찰스 배비지의 차분 기관에도 비트의 개념은 존재하지 않는다. 컴퓨터가 언제부터 비트와 함께 했는지 알아 보기 전, 먼저 아날로그(예: 손가락)와 디지털(예: 자)에 대해 알아야 한다. 우리는 자로 실수를 표현할 수 있으나 손가락으로는 할 수 없다. 자는 수학적으로 연속적이나 손가락은 이산적(하나하나 다른 존재로 구분됨)이기 때문이다. 전자기술 영역에서 아날로그는 연속적인 것을, 디지털은 이산적인 것을 뜻하는데 실수를 계산할 수 있단 측면에서 아날로그가 계산에 있어 적합해 보이나 큰 숫자를 표현하기 위해 그만큼 커다란 자가 필요하고 이는 에너지의 효율을 위해 작은 하드웨어를 추구하는 흐름에 어긋난다. 뿐만 아니라 우리가 연속성을 이용해 계산을 하면 외부의 그 어떤 방해도 없어야만 정밀도 높은 측정이 가능한데 회로 내에서 이러한 누화 효과를 막는 건 실질적으로 불가능하므로 높은 정밀도를 추구해야 한다면 잡음 내성을 가진 디지털 회로는 필수적인 존재다.        
<br/>

### 221016(8일차) 98p ~ 108p
정밀도를 위해 많은 엔지니어들은 하단부, 직선부, 상단부가 나누어져 출력의 단계가 구분된 전이 함수를 이용해 아날로그로부터 디지털을 구현하고자 했다.앞서 출력값이 급변하는 지점(판정 기준)을 문턱값이라 한다. 이러한 문턱값이 비트에 적용될 경우, 0과 1만이 존재하는 만큼 출력값의 변화폭이 크기 때문에 전이 함수의 하단부(차단)와 상단부(포화) 간의 간격이 더욱 넓어져 그만큼의 재량권이 증가한다. 컴퓨터에 대해 이해하기 위해선 원동력이라 할 수 있는 전기 이야기를 안 할 수가 없다. 전기를 흐르게 하거나 차단하는 게이트 밸브의 열고 닫힘은 곧 1과 0과 같으며 이를 이용해 논리 연산자의 구현이 가능해진다. 전기는 물과 같기 때문에 흐름에 있어 전파 지연이 발생할 수 있고 전류는 전압과 저항에 영향을 받는다(옴의 법칙: 전류는 전압을 저항으로 나눈 값과 같음, I = V/R). 이러한 전기는 부도체를 이용해 만든 스위치를 통해 제어할 수 있으며 전기의 흐름을 발생 또는 통제하는 전체적인 시스템을 회로라고 하며 이는 스키매틱(회로도)을 통해 문서화된다. 스위치가 단극인지 쌍극인지에 따라 통제할 수 있는 회로의 수가 다르며 만약 스위치 하나로 켜고 끄는 걸 동시에 하는 게 아닌 스위치마다 다른 기능(켜고 끔)을 부여하고 싶다면 단극쌍투 스위치를 이용하면 된다.  
<br/>

### 221018(9일차) 109p ~ 115p
전자적 기술은 역사를 거쳐 발전했고 단순함에서 복잡함으로 나아갔고 그 첫 번째 역사로는 릴레이가 있다. 선을 말아 코일로 만들고 전류를 흐르게 하면 해당 코일은 전자석이 되며, 릴레이는 이러한 전자석을 통해 회로의 스위치를 움직인다. 하지만 릴레이는 속도가 느리고 사이에 이물질이 있으면 성능이 급격하게 저하되기 때문에 이를 위한 대체재로 물체를 충분히 가열하면 전자가 튀어나오는 열전자 방출을 원리로 하는 진공관을 만들었고 뒤이어 진공관과 비슷하지만 반도체(도체와 반도체 사이를 오가는 물질)로 이뤄진 기판 또는 슬랩 위에 만들어지는 트렌지스터가 만들어졌으며 해당 방식이 가장 우세하게 쓰이고 있으며 추후 발명한 직접 회로를 통해 트렌지스터에 복잡한 시스템을 구현하는 것을 더욱 적은 부품으로 만드는 게 가능해졌다. 이렇듯 사람들은 더 작고 더 저렴하고 에너지를 효율적으로 사용할 수 있도록 회로를 만드는 기술 개발에 힘을 썼다.   
<br/>

### 221022(10일차) 116p ~ 122p
논리 연산을 수행하는 회로를 논리 게이트(게이트)라 한다. 게이트 IC(집적 회로)를 사용하면 회로를 처음부터 설계하지 않고 복잡한 회로 구현이 가능하며 게이트의 종류로는 AND, OR, XOR, 인버터(NOT)가 있다. 하지만 AND 게이트나 OR 게이트는 NAND(not and)와 NOR(not or)에 트렌지스터를 붙여 출력을 반전시키는 방식으로 구성되어 효율 측면에서 좋지 않기 때문에 디지털 회로 설계에 기본적으로 사용하는 게이트는 NAND와 NOR이다. 드모르간 법칙에 의해 NAND 게이트만으로 AND을 나타낼 수 있으나 반대의 경우는 장치가 필요하므로 NAND(더불어 NOR)을 기본적으로 썼을 때 더 많은 논리 표현이 가능하다. 이런 게이트는 논리 신호(0 또는 1)를 받아 처리하나 앞서 설명했던 디지털적 장치를 이용한다 해도 신호의 속도가 느릴 경우 잡음이 발생해 출력 신호에 글리치(작은 오류)가 발생한다. 이는 판정 기준이 이력(과거 현상)에 따라 달라지는 이력 현상을 통해 해결할 수 있는데 즉, 0에서 1이 될 때와 1에서 0이 될 때에 다른 문턱값을 매기면 값이 변동 간격이 기존에 비해 크게 변하고 잡음 내성 또한 강해진다. 이러한 원리를 사용하는 게이트로 슈미트 트리거가 있다. 하지만 이력만으로도 충분하지 못할 경우가 있는데 이때는 차동(차이, 격차) 신호를 이용한다. 이력은 문턱값이라는 절대 기준에 평가되었으나 차동 신호는 서로 반전관계에 있는 신호 쌍 간의 차이로 측정하기 때문에 잡음의 영향을 덜 받는다. 물론 차등 신호 역시 압도적인 잡음에는 영향을 받게 되는데 이때는 공통 모드 판별비(CMRR)를 이용해 처리 가능한 잡음의 양을 미리 표시한다. 뿐만 아니라 회로 설계자들은 전파 지연도 가정하며 게이트의 효율적 작동을 고민해야 한다.   
<br/>

### 221023(11일차) 123p ~ 134p
게이트의 출력에는 다양한 유형이 존재한다. 일반적 게이트 출력은 토템폴이라 하는데 이는 나란히 붙은 (1과 0을 담당는)트렌지스터 모양이 원기둥 토템과 닮아 붙여진 이름으로 출력의 1을 얻기 위해 출력과 높은 논릿값 1을 연결하는 것을 액티브 풀업이라 말하며 토템폴 출력을 서로 연결하면 음극과 양극을 서로 연결하는 모양이 되어 불가능하다. 오픈 컬렉터/오픈 드레인 출력은 액티브 풀업이 없기 때문에 서로 연결이 가능하며 필요하면 패시브 풀업(풀업 저항을 논리적인 1값을 공급하는 공급 전압에 연결)에 연결할 수 있다. 하지만 해당 방식은 액티브 풀업만큼 응답이 빠르지 않아 이를 해결하기 위한 트라이스테이트 출력이 있다. 기존의 두 가지 상태에서 꺼진 상태(hi-Z(임피던스))인 세 번째 상태를 더해 함께 다루는 방식으로 이로 인해 활성화 입력이 존재한다. 해당 출력을 사용하면 수많은 장치를 서로 선으로 직접 연결할 수 있으나 한 번에 한 개의 장치만 활성화해야 한다. 게이트의 등장으로 하드웨어 설계 과정은 단순해졌고 다양한 게이트 조합이 등장했는데 가산기, 디코더, 디멀티플렉서, 실렉터가 그것이다. 가산기는 비트의 덧셈에서 작동되는 논리 연산에서 착안해 XOR 게이트와 AND 게이트를 조합해 만들 수 있으며 디코더는 인코딩된 수를 개별 비트의 집합으로 만드는 기능을 논리 게이트로 구현한 것이다. 이를 이용해 디멀티플렉서(디먹스)를 만들 수 있는데 입력을 몇 가지 출력 중 한 곳에 전달할 수 있다. 마지막 실렉터(또는 멀티플렉서(먹스))는 마찬가지로 디코더에 게이트를 추가해 구현하며 해당 스키매틱을 보면 디먹스를 뒤집은 모양이다.   
<br/>

### 221028(12일차) 135p ~ 141p
논리는 분명 컴퓨터 처리에 있어 중요한 역할을 하나 논리의 중간에 위치한 값을 저장하지 못하면 결과를 내지 못하는 경우가 많다. 따라서 앞뒤 순서의 개념이 존재하는 순차 논리가 필요하다. 순서, 즉 시간의 선후를 따지기 위해선 주기 함수가 필요하며 이때 주기는 진자가 오가는 시간을 주기로써 사용하며 컴퓨터는 이를 좀 더 현대적인 방법으로 사용한다. 출력값이 0과 1 사이를 진동하는 것을 이용해 시간을 측정하는데 적은 비용으로 효율적으로 측정하기 위해 안정적인 주파수로 진동하는 크리스털 발진자를 자주 이용한다. 이에 덧붙여 컴퓨터에 클록(시간을 셀 수 있게 해 주는 신호)을 제공하여 회로의 페이스를 제공하여 발생할 수 있는 지연을 미리 방지해 시간을 측정할 수 있게 한다. 이렇게 시간 표현이 가능하게 만든 후 래치를 이용하여 해당 흐름을 1비트씩 기록한다. 회로가 자신의 과거를 기억할 수 있도록 하는 것인데 입력과 출력에서 발생하는 값을 OR 게이트와 출력을 입력에 묶는 방식인 되먹임을 이용해 과거값과 비교하여 참/거짓을 판별하게 하는 원리라 요약할 수 있다.  
<br/>

### 221029(13일차) 141p ~ 147p
플립플롭은 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 에지를 바탕으로 데이터 변화를 잡아내는 래치를 말하며 논리 수준이 0에서 1으로 바뀌면 양의 에지에 의해 변화가 촉발되는 플립플롭과 반대의 경우에 변화가 촉발되는 플립플롭 두 가지가 존재한다. 에지에 의해 상태 변화가 촉발되는 장치의 상태 변화를 볼 땐 전파 지연 외에도 클록 에지가 발생(0에서 1로 전이)하기 전에 신호가 얼마나 오랫동안 안정적으로 유지되어야 하는지 나타내는 설정 시간, 발생한 이후 얼마나 오랫동안 안정적으로 유지되어야 하는지 나타내는 유지 시간을 고려해야 한다. 이러한 플립플롭을 응용한 회로 중에는 순서대로 수를 세는 카운터가 있는데 시그널이 0에서 1로 가는 횟수를 세서 3비트 수로 나타내는 걸 리플 카운터(물이 퍼지듯 왼쪽에서 오른쪽으로 퍼져 나간다는 의미)라 부른다. 이를 비동기 카운터로 보게 되면 언제 결과를 살펴야 정확한지 판별이 어렵기 때문에 동기적 카운터로 설정하여 리플 카운터의 타이밍 문제를 해결한다. 이러한 플립플롭을 이용하면 값을 쉽게 기억할 수 있어 레지스터 회로 구축도 용이하고 이를 이용해 여러 비트를 저장할 수 있다.  
<br/>

### 221030(14일차) 148p ~ 152p
앞서 말했던 레지스터를 이용해 많은 정보를 저장하고자 한다면 일단 각 레지스터에 번호, 즉 주소를 부여해 지정한 주소에 해당하는 레지스터의 출력을 실렉터 또는 트라이스테이트를 이용해 발생시킨다. 이렇게 레지스터를 기반으로 구성된 메모리 컴포넌트는 연결 지점이 아주 많게 되는데 입력과 출력 데이터 연결을 합치고 제어 신호를 사용하면 연결을 줄일 수 있다. 주소와 데이터에는 개별 신호 대신 큰 화살표를 사용한 것을 볼 수 있는데 이런 연관된 신호를 버스라 부르며 이는 비트를 이동시키는 역할을 한다. 이렇게 이동된 데이터는 행과 열로 나누어진 메모리 배열(메모리 칩) 내부로 가게 된다. 이러한 메모리 칩은 깊이x너비로 크기를 표시하는데 256x6 칩은 너비(열)가 8, 깊이(행)가 256개인 메모리 지점을 제공한다 할 수 있다. 이러한 메모리를 임의 접근 메모리(램)이라 하는데 램을 사용하면 메모리 위치 중 원하는 곳 어디든 원하는 순서로 쓰거나 읽을 수 있다. 동적 램(DRAM)은 커패시터라는 작은 버킷에 트랜지스터 한 개만을 이용하는데 버킷이 가끔 이 버킷에 문제가 발생해 가끔 메모리를 갱신해야 하는 부작용이 있다. 이러한 동적 램이든 한 비트에 트랜지스터가 6개가 사용되는 정적 램(SRAM)이든 모두 휘발성 메모리라 전원과 상관없이 계속 메모리를 묶어두기 위한 비휘발성 RAM인 코어 메모리가 등장하게 됐다.  
<br/>


