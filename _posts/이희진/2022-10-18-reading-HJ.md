---
layout: single
title: "이희진 독서일지(1): 한 권으로 읽는 컴퓨터 구조와 프로그래밍"
categories: 독서일지
tags: 이희진
---

### 221001(1일차) 34p ~ 49p
프로그래밍 언어는 결국 사람이 만들었기 때문에 불완전성(버그)이 존재한다. 이에 대처하기 위함도 있으나 기본적으로 좋은 프로그래밍은 컴퓨터에게 효율적이고 정확하게 명령하는 것이므로 컴퓨터를 이해하는 건 좋은 기반이 된다. 하지만 메모리 관리가 필수였던 C 언어와 달리 메모리 걱정을 하지 않아도 된 자바를 비롯해 비슷한 언어들이 대거 등장하게 된 것은 분명한 발전이나 컴퓨터에 대한 이해를 불필요하게 여겨 프로그래머의 역량을 낮추는 계기가 되었으므로 이에 대한 역량 향상은 필수적이다.  
<br/>

### 221003(2일차) 51p ~ 57p
컴퓨터 언어는 자연어(인간의 언어)와 유사하다. 둘은 기호(문자)가 들어갈 상자, 상자에 들어갈 기호, 상자의 순서로 나눌 수 있는데 컴퓨터 언어에서 이 상자를 비트(2진법 사용을 뜻하는 binary와 숫자를 뜻하는 digit의 합성어)라고 칭한다. 비트 사용법 중 하나로 논리 연산이 있는데 대표적인 게 불리언 대수로, 기본적인 연산자로 NOT, AND, OR, XOR(첫 번째 비트와 두 번째 비트가 서로 다른 값이어야 참)이 있다. 드모르간 법칙(! false === true)을 바탕으로 AND 연산자로 OR을 나타낼 수 있으나 연산자의 사용은 적을수록 효율적이다.  
<br/>

### 221004(3일차) 58p ~ 67p
비트는 2진수로 숫자를 표현할 수 있다. 2의 거듭제곱 단위로 나눈 상자에 나누어 0과 1을 담아 숫자를 표현하며 이때 0과 1의 개수에 따라 비트의 수가 결정된다(e.g. 5,028는 13비트). 가장 오른쪽의(수를 가장 작게 변화시키는 유효) 비트를 LSB, 가장 왼쪽의(가장 크게 변화시키는 유효) 비트를 MSB라 한다. 2진수 또한 덧셈과 뺄셈이 가능하며 비트로 음수를 표현할 땐 '2의 보수'를 사용한다. 이때 '2의 보수'란 양수 2진수에 NOT 연산자를 추가한(0과 1을 반대로 한) 후 1을 더하는 방식을 뜻한다(e.g. 1 = 001 / -1 = 111).  
<br/>

### 221006(4일차) 68p ~ 73p
앞서 말한 숫자 표현은 정수에 한정됐으나 비트로 실수 표현 또한 가능하다. 고정소수점(2의 거듭제곱을 분모로 하는 분수들을 이용해 2진법으로 소수 표현), 부동소수점 표현법 등 다양하게 있으나 해당 방법들의 비효율성(비트의 낭비)을 해결하기 위해 등장한 것이 'IEEE 부동소수점 수 표준'이다. 0.0012를 1.2(가수) x 10(밑)⁻³(지수)로 표현하는 것처럼 밑 2의 지수만 변경해 표현하는 부동소수점에 트릭을 사용해 정밀도를 높인 버전(1. 정규화(가수를 조정해 맨 앞에 0이 없게 만듦), 2. 맨 왼쪽 비트의 1을 생략함)으로 기본 정밀도 부동소수점과 2배 정밀도 부동소수점이 자주 쓰인다.  
<br/>

### 221007(5일차) 74p ~ 78p
2진수의 조작에 있어 불편함을 최소화시키기 위해 사람들은 다양한 표현법을 강구했다. 8진 표현법과 16진 표현법이 그것인데 각각 2진수 비트들을 3개씩, 4개씩 묶어 표현한다. 즉, 11010011111111000001 같은 엄청난 숫자를 4개씩 묶어 (1101/0011/1111/1100/0001) 표현하고 이를 각 진수 표현법의 규칙에 맞춰 변환하면 10몇개의 숫자들이 한 자릿수의 숫자 및 문자로 정리가 된다(예: 1101/0011/1111/1100/0001 => d3fc1). 그렇다면 이런 다양한 표기법을 컴퓨터는 어떻게 구분할까. 구분할 수 있다. 0부터 시작하면 8진수, 1~9 사이의 숫자로 시작하면 10진수, 0x가 앞에 붙으면 16진수다. 이러한 진수 표현에 있어 절대 빠질 수 없는 비트들은 너무 작기 때문에 효율적인 표현을 위해 일정 개수(4, 8, 16 등)로 묶은 덩어리에 이름을 붙여 표현한다(니블, 바이트, 하프워드 등).  
<br/> 

### 221012(6일차) 79p ~ 89p
비트로 수를 표현할 수 있다. 그리고 이 수로 문자를 표현할 수 있다. 아스키 코드는 그 방법 중 하나로 키보드 위 모든 기호에 대해 7비트 수 값을 할당했다. (예: 65는 대문자 A를 뜻함) 키보드 위 문자 외에도 아스키 코드로 아스키 제어 문자 또한 나타낼 수 있다(예: 텍스트 시작, null 등). 또한 영어만 지원했던 기존과 달리 다양한 언어의 표준(유니코드)도 도입하여 문자에 16비트 코드를 부여한다. 하지만 아무리 비트가 저렴해졌다고 해도(이 때문에 기존 7비트에서 16비트까지 증가) 문자 표현에 있어서 8비트면 충분하기 때문에 '유니코드 변환 형식 8비트(UTF-8)'를 아스키가 아닌 문자에 대한 주된 인코딩(다른 비트 패턴 표현을 위해 사용한 비트 패턴) 방법으로 사용할 수 있다. 인코딩의 방식은 다양하고 그 예로 QP(쿼티드 프린터블)인코딩, 베이스64 인코딩, URL 인코딩이 있으며 해당 인코딩들은 기본적으로 문자 8비트 데이터를 송수신 가능한 비트로 쪼개어 인코딩한다. 마지막으로, 수로 색 또한 표현할 수 있다. 컴퓨터는 가산 색 시스템을 바탕으로 한 RGB 모델을 통해 색을 표현한다. RGB은 적, 녹, 청 각각의 진함 정도를 숫자로 표현하며 해당 색에는 각각 8비트가 할당된다. 하지만 여기서 미사용되는 8비트가 존재하는데 이는 색의 투명도를 담당하는 부분이다. 또한 이러한 색은 16진 트리플렛(예: #ffff00은 노란색)을 이용해 각각의 8비트 값을 16진 표기를 통해 두 자리 문자로 바꿔서도 표현할 수 있다.   
<br/>

### 221015(7일차) 91p ~ 97p
비트는 매우 중요하나, 톱니바퀴로 돌아가던 계산기의 시초에 비트는 존재하지 않았고 계산자를 이용한 오트레드의 기계식 계산기와 찰스 배비지의 차분 기관에도 비트의 개념은 존재하지 않는다. 컴퓨터가 언제부터 비트와 함께 했는지 알아 보기 전, 먼저 아날로그(예: 손가락)와 디지털(예: 자)에 대해 알아야 한다. 우리는 자로 실수를 표현할 수 있으나 손가락으로는 할 수 없다. 자는 수학적으로 연속적이나 손가락은 이산적(하나하나 다른 존재로 구분됨)이기 때문이다. 전자기술 영역에서 아날로그는 연속적인 것을, 디지털은 이산적인 것을 뜻하는데 실수를 계산할 수 있단 측면에서 아날로그가 계산에 있어 적합해 보이나 큰 숫자를 표현하기 위해 그만큼 커다란 자가 필요하고 이는 에너지의 효율을 위해 작은 하드웨어를 추구하는 흐름에 어긋난다. 뿐만 아니라 우리가 연속성을 이용해 계산을 하면 외부의 그 어떤 방해도 없어야만 정밀도 높은 측정이 가능한데 회로 내에서 이러한 누화 효과를 막는 건 실질적으로 불가능하므로 높은 정밀도를 추구해야 한다면 잡음 내성을 가진 디지털 회로는 필수적인 존재다.        
<br/>

### 221016(8일차) 98p ~ 108p
정밀도를 위해 많은 엔지니어들은 하단부, 직선부, 상단부가 나누어져 출력의 단계가 구분된 전이 함수를 이용해 아날로그로부터 디지털을 구현하고자 했다.앞서 출력값이 급변하는 지점(판정 기준)을 문턱값이라 한다. 이러한 문턱값이 비트에 적용될 경우, 0과 1만이 존재하는 만큼 출력값의 변화폭이 크기 때문에 전이 함수의 하단부(차단)와 상단부(포화) 간의 간격이 더욱 넓어져 그만큼의 재량권이 증가한다. 컴퓨터에 대해 이해하기 위해선 원동력이라 할 수 있는 전기 이야기를 안 할 수가 없다. 전기를 흐르게 하거나 차단하는 게이트 밸브의 열고 닫힘은 곧 1과 0과 같으며 이를 이용해 논리 연산자의 구현이 가능해진다. 전기는 물과 같기 때문에 흐름에 있어 전파 지연이 발생할 수 있고 전류는 전압과 저항에 영향을 받는다(옴의 법칙: 전류는 전압을 저항으로 나눈 값과 같음, I = V/R). 이러한 전기는 부도체를 이용해 만든 스위치를 통해 제어할 수 있으며 전기의 흐름을 발생 또는 통제하는 전체적인 시스템을 회로라고 하며 이는 스키매틱(회로도)을 통해 문서화된다. 스위치가 단극인지 쌍극인지에 따라 통제할 수 있는 회로의 수가 다르며 만약 스위치 하나로 켜고 끄는 걸 동시에 하는 게 아닌 스위치마다 다른 기능(켜고 끔)을 부여하고 싶다면 단극쌍투 스위치를 이용하면 된다.  
<br/>

### 221018(9일차) 109p ~ 115p
전자적 기술은 역사를 거쳐 발전했고 단순함에서 복잡함으로 나아갔고 그 첫 번째 역사로는 릴레이가 있다. 선을 말아 코일로 만들고 전류를 흐르게 하면 해당 코일은 전자석이 되며, 릴레이는 이러한 전자석을 통해 회로의 스위치를 움직인다. 하지만 릴레이는 속도가 느리고 사이에 이물질이 있으면 성능이 급격하게 저하되기 때문에 이를 위한 대체재로 물체를 충분히 가열하면 전자가 튀어나오는 열전자 방출을 원리로 하는 진공관을 만들었고 뒤이어 진공관과 비슷하지만 반도체(도체와 반도체 사이를 오가는 물질)로 이뤄진 기판 또는 슬랩 위에 만들어지는 트렌지스터가 만들어졌으며 해당 방식이 가장 우세하게 쓰이고 있으며 추후 발명한 직접 회로를 통해 트렌지스터에 복잡한 시스템을 구현하는 것을 더욱 적은 부품으로 만드는 게 가능해졌다. 이렇듯 사람들은 더 작고 더 저렴하고 에너지를 효율적으로 사용할 수 있도록 회로를 만드는 기술 개발에 힘을 썼다.   
<br/>
