---
title: "이희진 독서일지(2): 한 권으로 읽는 컴퓨터 구조와 프로그래밍"
layout: post
comments: true
categories: [이희진/독서일지]
tags: []
---

### 221106(17일차) 165p ~ 175p
엔디안이란 가장 왼쪽 자리에 0번 바이트가 들어가는지 아니면 마지막 바이트가 들어가는지와 같은 방식의 차이를 표현한다. 왼쪽에 마지막 바이트가 들어간다면 리틀 엔디안, 반대의 경우 빅 엔디안이라 한다. 엔디안을 고려하지 않으면 데이터 순서가 엉망이 되므로 이는 매우 중요하다. 컴퓨터에서 발생하는 입력/출력을 줄여 I/O라 하는데 이와 메모리는 엄연히 다른 영역이므로 각 영역 간의 거리 또한 다르다. 메모리의 크기가 늘어나면서 아무 메모리와 연관되지 않은 데이터 주소가 많아져 근래에는 메모리 거리에 I/O 장치를 연결하는 방식이 생겼다. CPU(중앙처리장치)란 컴퓨터의 중심부로 실제 계산을 처리하는 컴퓨터 부품이다. 해당 부품은 실렉터와 논리 게이트를 연결해 산술 계산, 불리언 대수 및 기타 연산을 수행하는 산술 논리 장치(ALU), 비트를 왼쪽 또는 오른쪽으로 1비트씩 이동시키는 시프트 레지스터(최근에는 속도가 더 빠른 배럴 시프터 사용), ALU에게 어떤 연산을 수행해야 하는지 알려 주고 결과를 메모리에 전달하는 실행 장치(제어 장치)로 구성되어 있다.   
<br/>
### 221111(18일차) 176p ~ 183p
16비트 크기의 명령어를 사용한다고 가정할 때 이를 4등분하는 게 합당하다 생각하지만 이렇게 될 경우 결과와 피연산자 주소에 4비트밖에 쓸 수 없기 때문에 쓸모있는 크기의 메모리를 가리킬 수 없는 경우도 발생한다. 때문에 주소 확장 레지스터를 두고 별도의 명령어를 사용해 상위 주소를 지정하게 한다. 이는 DRAM 주소 지정 기법을 활용하는 것으로 인텔은 이를 PAE(물리 주소 확장)이라고 부른다. 하지만 이러한 방식에도 중요한 단점이 있는데 3주소 명령어가 잘 작동하지 않는다는 게 바로 그것이다. 3주소 명령어는 세 가지 메모리 위치를 한꺼번에 지정하는 메모리 주소 접근을 사용해 각기 다른 장치에 존재하는 메모리 블록을 서로 이어지게 하기 위한 별도의 명령어가 필요하게 된다. 이렇게 되면 회로가 아주 복잡해지게 되는데 누산기 레지스터를 이용하면 저장 명령어의 추가가 필요하나 더 많은 주소 비트를 사용할 수 있게 된다. 하지만 아직 사용 가능한 주소가 충분하다고 할 수 없다. 이때 간접 주소 지정을 추가하면 더 많은 메모리를 사용할 수 있게 되는데 이 방식에서 CPU는 명령어에 들어 있는 값을 피연산자 주소로 해석하지 않고 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용한다. 이렇게 직접 또는 간접 주소 지정 모드만으로도 메모리를 다루는 건 충분하나 상수를 지정해야 할 때(누산기에 수를 세기 위해 숫자를 넣는 경우)도 있으므로 이때를 위한 즉시 주소 지정 모드를 추가하면 좋다. 하지만 현재까지 다룬 내용은 주로 값과 관련된 것으로 여러 조건(덧셈, 뺄셈, 비교 연산 등) 코드를 다루는 명령어 또한 필요하므로 이를 담당하는 레지스터 또한 고려해야 한다. 또한 고려해야 할 점이 처음부터 끝까지 전부 수행하지 않고 일부만 수행하고자 하는 경우인데 이를 위한 명령어가 바로 분기 명령어로 이러한 분기 명령어에는 조건을 저장하기 위한 비트가 필요하다. 이렇듯 여러 명령어 요소들을 조합하면 프로그램을 작성해 실제 컴퓨터에게 어떠한 일을 하라고 지시할 수 있는 발판이 마련된다.   
<br/>
### 221112(19일차) 184p ~ 192p
지금까지 다룬 내용들을 하나하나 모아 실제 컴퓨터를 만들 수 있는데 이때 일종의 '접착제'가 필요하다. 명령어 레지스터에 관련된 얘기부터 해 보면 명령어가 실행되는 과정은 두 단계(페치, 실행)로 이루어진 상태 기계로 설명할 수 있다. 컴퓨터는 페치를 이용해 메모리에서 명령어를 가져오면 CPU에 추가된 명령어 레지스터에 현재 실행 중인 명령어를 저장하고 뒤이어 메모리에 있는 데이터도 명령어 레지스터에 들어가게 된다. 데이터의 출력 및 입력 또한 제어가 필요하며 이때도 명령어는 중요하다. 마찬가지로 페치, 실행 두 단계를 거치며 각 단계는 간단하지 않고 복잡하므로 각 단계를 추적할 카운터가 필요한데 이 카운터의 내용, 명령 코드, 모드 부분이 제어 신호를 결정한다. 이때 정해진 개수의 입력이 있고 이 입력들을 정해진 개수의 출력에 연관시켜야 하는데 출력에 어떤 규칙성이 없을 때가 있는데 이런 모양을 보고 랜덤 논리가 가득 차 있다고 한다. 또는 랜덤 논리 대신 적당한 크기의 메모리를 사용해 카운터의 출력과 명령어의 명령코드와 주소 지정 모드 부분을 메모리 주소에 연결해 마치 하나의 컴퓨터를 구현한 상태가 되는데 이를 마이크로코드를 썼다고 표현한다. 마이크로코드 메모리로 ROM을 사용하며 때에 따라 RAM를 쓰거나 섞어 사용하기도 한다. 이러한 제어 회로를 탐구하던 중 설계자들은 복잡한 명령어 중 상당수가 쓰이지 않는다는 걸 알게 됐고 복잡한 명령어를 단순한 명령어를 조합해 처리하는 RISC 기계를 사용하기도 한다(기존의 방식은 CISC). 또한 그래픽 처리에 특화된 GPU(그래픽 처리 장치) 또한 컴퓨터에 있어 중요한 장치다.    
<br/>
### 221113(20일차) 193p ~ 198p
컴퓨터 아키텍처란 컴퓨터의 여러 구성요소를 배치하는 방법을 뜻한다. 어떻게 배치하느냐에 따라 프로그램 및 메모리의 조직적 관리에 영향을 미치는데 일단 가장 흔한 두 가지 컴퓨터 구조를 말하자면 폰 노이만 구조와 하버드 구조를 말할 수 있다. 이 두 구조의 유일한 차이는 메모리 배열뿐이며 메모리에서 동시에 명령어와 데이터를 가져올 수 없나 있나의 차이다(폰 노이만 구조의 경우 데이터 버스와 주소 버스가 하나뿐이라 동시에 가져올 수가 없다). 기존과 같이 단일 CPU를 사용하는 것만으로 요구하는 성능을 충족할 수 없으므로 작아진 회로 크기를 활용해 여러 코어가 들어간 멀티코어 프로세서인 CPU를 만들어 사용하며 이전의 단일 CPU는 프로세서 코어라 한다. 이 외에도 물리적인 패키징에 따라서도 구조를 구분할 수 있는데 메모리와 I/O가 같은 패키지에 들어 있지 않는 경우의 프로세서를 마이크로프로세서, 모든 요소를 한 칩 안에 넣은 경우는 마이크로컴퓨터라 한다. 마이크로프로세서는 보통 큰 시스템에 들어가는 부품으로 사용되며 마이크로컴퓨터는 가전에서 쉽게 찾을 수 있는 작은 컴퓨터라 생각하면 된다. 함수(프로시저, 서브루틴이라고도 한다)는 코드를 재사용하는 중요한 수단인데 함수를 호출하는 부분에서 함수를 실행하고 원래 자리로 돌아올 방법이 필요한데 이때 필요한 게 바로 프로그램 카운터 개념이다. 돌아가야 하는 저 위치가 바로 프로그램 카운터의 값이며 이러한 과정을 돕는 명령어(분기 명령어 등)들을 이용해 해당 기능을 구현할 수 있다.    
<br/>

