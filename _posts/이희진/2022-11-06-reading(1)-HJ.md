---
title: "이희진 독서일지(2): 한 권으로 읽는 컴퓨터 구조와 프로그래밍"
layout: post
comments: true
categories: [이희진/독서일지]
tags: []
---

### 221106(17일차) 165p ~ 175p
엔디안이란 가장 왼쪽 자리에 0번 바이트가 들어가는지 아니면 마지막 바이트가 들어가는지와 같은 방식의 차이를 표현한다. 왼쪽에 마지막 바이트가 들어간다면 리틀 엔디안, 반대의 경우 빅 엔디안이라 한다. 엔디안을 고려하지 않으면 데이터 순서가 엉망이 되므로 이는 매우 중요하다. 컴퓨터에서 발생하는 입력/출력을 줄여 I/O라 하는데 이와 메모리는 엄연히 다른 영역이므로 각 영역 간의 거리 또한 다르다. 메모리의 크기가 늘어나면서 아무 메모리와 연관되지 않은 데이터 주소가 많아져 근래에는 메모리 거리에 I/O 장치를 연결하는 방식이 생겼다. CPU(중앙처리장치)란 컴퓨터의 중심부로 실제 계산을 처리하는 컴퓨터 부품이다. 해당 부품은 실렉터와 논리 게이트를 연결해 산술 계산, 불리언 대수 및 기타 연산을 수행하는 산술 논리 장치(ALU), 비트를 왼쪽 또는 오른쪽으로 1비트씩 이동시키는 시프트 레지스터(최근에는 속도가 더 빠른 배럴 시프터 사용), ALU에게 어떤 연산을 수행해야 하는지 알려 주고 결과를 메모리에 전달하는 실행 장치(제어 장치)로 구성되어 있다.   
<br/>
### 221111(18일차) 176p ~ 183p
16비트 크기의 명령어를 사용한다고 가정할 때 이를 4등분하는 게 합당하다 생각하지만 이렇게 될 경우 결과와 피연산자 주소에 4비트밖에 쓸 수 없기 때문에 쓸모있는 크기의 메모리를 가리킬 수 없는 경우도 발생한다. 때문에 주소 확장 레지스터를 두고 별도의 명령어를 사용해 상위 주소를 지정하게 한다. 이는 DRAM 주소 지정 기법을 활용하는 것으로 인텔은 이를 PAE(물리 주소 확장)이라고 부른다. 하지만 이러한 방식에도 중요한 단점이 있는데 3주소 명령어가 잘 작동하지 않는다는 게 바로 그것이다. 3주소 명령어는 세 가지 메모리 위치를 한꺼번에 지정하는 메모리 주소 접근을 사용해 각기 다른 장치에 존재하는 메모리 블록을 서로 이어지게 하기 위한 별도의 명령어가 필요하게 된다. 이렇게 되면 회로가 아주 복잡해지게 되는데 누산기 레지스터를 이용하면 저장 명령어의 추가가 필요하나 더 많은 주소 비트를 사용할 수 있게 된다. 하지만 아직 사용 가능한 주소가 충분하다고 할 수 없다. 이때 간접 주소 지정을 추가하면 더 많은 메모리를 사용할 수 있게 되는데 이 방식에서 CPU는 명령어에 들어 있는 값을 피연산자 주소로 해석하지 않고 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용한다. 이렇게 직접 또는 간접 주소 지정 모드만으로도 메모리를 다루는 건 충분하나 상수를 지정해야 할 때(누산기에 수를 세기 위해 숫자를 넣는 경우)도 있으므로 이때를 위한 즉시 주소 지정 모드를 추가하면 좋다. 하지만 현재까지 다룬 내용은 주로 값과 관련된 것으로 여러 조건(덧셈, 뺄셈, 비교 연산 등) 코드를 다루는 명령어 또한 필요하므로 이를 담당하는 레지스터 또한 고려해야 한다. 또한 고려해야 할 점이 처음부터 끝까지 전부 수행하지 않고 일부만 수행하고자 하는 경우인데 이를 위한 명령어가 바로 분기 명령어로 이러한 분기 명령어에는 조건을 저장하기 위한 비트가 필요하다. 이렇듯 여러 명령어 요소들을 조합하면 프로그램을 작성해 실제 컴퓨터에게 어떠한 일을 하라고 지시할 수 있는 발판이 마련된다.   
<br/>
### 221112(19일차) 184p ~ 192p
지금까지 다룬 내용들을 하나하나 모아 실제 컴퓨터를 만들 수 있는데 이때 일종의 '접착제'가 필요하다. 명령어 레지스터에 관련된 얘기부터 해 보면 명령어가 실행되는 과정은 두 단계(페치, 실행)로 이루어진 상태 기계로 설명할 수 있다. 컴퓨터는 페치를 이용해 메모리에서 명령어를 가져오면 CPU에 추가된 명령어 레지스터에 현재 실행 중인 명령어를 저장하고 뒤이어 메모리에 있는 데이터도 명령어 레지스터에 들어가게 된다. 데이터의 출력 및 입력 또한 제어가 필요하며 이때도 명령어는 중요하다. 마찬가지로 페치, 실행 두 단계를 거치며 각 단계는 간단하지 않고 복잡하므로 각 단계를 추적할 카운터가 필요한데 이 카운터의 내용, 명령 코드, 모드 부분이 제어 신호를 결정한다. 이때 정해진 개수의 입력이 있고 이 입력들을 정해진 개수의 출력에 연관시켜야 하는데 출력에 어떤 규칙성이 없을 때가 있는데 이런 모양을 보고 랜덤 논리가 가득 차 있다고 한다. 또는 랜덤 논리 대신 적당한 크기의 메모리를 사용해 카운터의 출력과 명령어의 명령코드와 주소 지정 모드 부분을 메모리 주소에 연결해 마치 하나의 컴퓨터를 구현한 상태가 되는데 이를 마이크로코드를 썼다고 표현한다. 마이크로코드 메모리로 ROM을 사용하며 때에 따라 RAM를 쓰거나 섞어 사용하기도 한다. 이러한 제어 회로를 탐구하던 중 설계자들은 복잡한 명령어 중 상당수가 쓰이지 않는다는 걸 알게 됐고 복잡한 명령어를 단순한 명령어를 조합해 처리하는 RISC 기계를 사용하기도 한다(기존의 방식은 CISC). 또한 그래픽 처리에 특화된 GPU(그래픽 처리 장치) 또한 컴퓨터에 있어 중요한 장치다.    
<br/>
### 221113(20일차) 193p ~ 198p
컴퓨터 아키텍처란 컴퓨터의 여러 구성요소를 배치하는 방법을 뜻한다. 어떻게 배치하느냐에 따라 프로그램 및 메모리의 조직적 관리에 영향을 미치는데 일단 가장 흔한 두 가지 컴퓨터 구조를 말하자면 폰 노이만 구조와 하버드 구조를 말할 수 있다. 이 두 구조의 유일한 차이는 메모리 배열뿐이며 메모리에서 동시에 명령어와 데이터를 가져올 수 없나 있나의 차이다(폰 노이만 구조의 경우 데이터 버스와 주소 버스가 하나뿐이라 동시에 가져올 수가 없다). 기존과 같이 단일 CPU를 사용하는 것만으로 요구하는 성능을 충족할 수 없으므로 작아진 회로 크기를 활용해 여러 코어가 들어간 멀티코어 프로세서인 CPU를 만들어 사용하며 이전의 단일 CPU는 프로세서 코어라 한다. 이 외에도 물리적인 패키징에 따라서도 구조를 구분할 수 있는데 메모리와 I/O가 같은 패키지에 들어 있지 않는 경우의 프로세서를 마이크로프로세서, 모든 요소를 한 칩 안에 넣은 경우는 마이크로컴퓨터라 한다. 마이크로프로세서는 보통 큰 시스템에 들어가는 부품으로 사용되며 마이크로컴퓨터는 가전에서 쉽게 찾을 수 있는 작은 컴퓨터라 생각하면 된다. 함수(프로시저, 서브루틴이라고도 한다)는 코드를 재사용하는 중요한 수단인데 함수를 호출하는 부분에서 함수를 실행하고 원래 자리로 돌아올 방법이 필요한데 이때 필요한 게 바로 프로그램 카운터 개념이다. 돌아가야 하는 저 위치가 바로 프로그램 카운터의 값이며 이러한 과정을 돕는 명령어(분기 명령어 등)들을 이용해 해당 기능을 구현할 수 있다.    
<br/>
### 221118(21일차) 199p ~ 206p
함수는 항상 간단한 코드로 이루어지지 않는다. 함수가 자기 자신을 호출하는 것을 재귀라 하는데 이러한 재귀를 이용해 재귀적 분할을 하고 이를 바탕으로 압축을 진행한다. 이러한 재귀를 이용해 압축 기능 함수를 구현하면 중요한 점이 있는데 들어 있는 반환값들이 덮어씌워지므로 반환 주소를 여럿 저장해야 한다. 재귀 외에도 컴퓨터가 데이터를 다루는 방식은 다양하다. 나뭇가지가 뻗어나가는 모양새처럼 root에서 leef까지 뻗어나가는 유향 비순환 그래프를 우리는 트리라 부르며 이때 트리의 한 경로를 우선적으로 탐색하고 그 다음에 다른 경로를 밑까지 내려가 탐색하는 방식을 깊이 우선 탐색, 동일 단계에 해당하는 노드부터 차례대로 탐색하는 방식을 너비 우선 탐색이라 한다. 또한 LIFO 구조를 가진 데이터 구조를 스택이라 하는데 이때 꽉 찬 스택에 또 값을 넣으려 할 때 발생하는 것을 스택 오버플로우라 하고 비어있는 스택에서 값을 추출하려 할 때 발생하는 건 스택 언더플로우라 한다. 이러한 스택은 앞서 말한 반환 주소 외에도 변수 저장에 있어서도 유용하게 사용된다. 순서도(flowchart)란 작업이 이루어지는 순서를 표현한 다이어그램으로 이를 통해 확률적 작업의 실패에 대비하기 위한 적절한 통합 주변장치를 이용한 인터럽트 시스템 배치를 구상할 수 있다. 이러한 인터럽트 시스템은 인터럽트 핸들러를 통해 제어한다.       
<br/>
### 221119(22일차) 207p ~ 212p
여러 프로그램을 동시에 진행하기 위해선 각 프로그램을 서로 전환시켜 줄 수 있는 일종의 관리자 프로그램이 필요한데 이를 운영체제 커널이라고 한다. OS는 타이머를 이용해 프로그램을 전환 시기를 판단하며 이러한 방식으로 실행시간을 조절하는 스케쥴링을 시분할이라 한다. 이러한 방식은 잘 작동하나 속도가 느린데 만약 프로그램마다 각기 다른 공간을 허용하면 속도 문제가 해결될 수 있다. 이때 이용할 수 있는 방법이 절대 주소 지정(명령어 주소가 특정 메모리 주소를 가리키게 함)과 상대 주소 지정(명령어에 들어 있는 주소를 0부터 시작하는 위치를 기준으로 하지 않고 명령어의 주소를 기준으로 하는 상대적 주소로 해석함)이 있다. 현재 인터넷 환경에서 이러한 멀티태스킹은 거의 필수가 되어 메모리 관리 장치(MMU)의 중요도가 높아졌다. MMU가 들어 있는 시스템은 가상 주소와 물리 주소를 구분하는데 이때 프로그램은 가상 주소를 사용해 작성되고 MMU는 물리 주소로 변환해 준다. 이러한 기능이 장치 안 값과 명령어에 들어 있는 주소를 더해 유효 주소를 계산하는 인덱스 레지스터와 다양한 차이가 있다. MMU는 상위쪽 부분을 페이지 테이블이라는 RAM 영역을 통해 주소를 변환하는데 이때 페이지는 메모리의 분할 상태를 담고 있으며 이러한 페이지 테이블에 제어 비트를 제공하는 경우가 있는데 실행 불가 비트와 읽기 전용 생성 비트가 있다. 프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 페이지 폴트 예외가 발생하는데 이러한 매커니즘으로 인해 프로그램은 필요한 만큼의 많은 메모리가 있다고 생각할 수 있게 됐다. 하지만 요청받은 메모리가 더 큰 경우가 더러 발생하는데 이때 현재 필요하지 않은 메모리 페이지를 대용량 저장장치(디스크)로 옮기는 스왑 아웃을 통해 해결한다. 이렇게 스왑 아웃된 페이지들은 작업 종료 후 다시 메모리로 불러들이는 스왑 인을 하게 되는데 이를 요구불 페이징이라 한다.        
<br/>
### 221120(23일차) 213p ~ 220p
MMU의 원활한 작동을 위해선 사용자 프로그램의 간섭을 최소화해야 한다. 이를 위해 만들어진 게 사용자 모드에 특권을 부여한 것으로 해당 특권을 통한 간섭이 아닌 이상 MMU에 대한 접근을 불가능하게 했다. 그 외에도 고려해야 할 부분이 상당한데 한 가지로 CPU가 주 메모리보다 빠르게 작동해 메모리를 기다리느라 많은 시간을 허비하는 문제도 있다. 이를 해결하가 위해 등장한 것이 캐시인데 하드웨어의 하나로 이를 CPU에 추가하면 캐시 실패가 발생해도 CPU는 고속 메모리 접근이 가능해져 유리하다. 프로세서 코어는 아주 복잡한 회로로 이루어져 있는데 몇 가지 연산을 코프로세서라 하는 단순한 회로에 위임하면 일반적 연산에 활용할 수 있는 공간을 더 확보할 수 있다. 또한 데이터가 정적인가 동적인가도 컴퓨터는 고려해야만 하는데 저장해야 하는 메시지 개수 및 크기를 알 수 없는 경우 즉 동적 데이터를 저장하는 공간을 힙, 흔히 생각할 수 있는 고정된 값인 정적 데이터를 저장하는 곳을 스택으로 구분하여 서로 충돌이 일어나지 않게 저장 공간을 구분했다. 앞서 설명한 함수를 다시 언급하자면 누군가에게 있어 유용한 함수를 하나하나 찾지 않고 한 곳에 모아둔 것이 있는데 이를 라이브러리라 하며 이러한 라이브러리 및 다양한 요소들이 모아져 구성되는 것이 바로 프로그램이며 이 연결고리를 링커라 부른다. 라이브러리의 연결 상태에 따라 동적 링크 또는 정적 링크로 구분할 수 있는데 정적 링크는 기존에 설명했던 바와 같이 프로그램 하나에 고정된 라이브러리라면 동적 링크는 여러 프로그램이 하나의 라이브러리를 공유해 연결되어 있는 걸 뜻한다.        
<br/>

