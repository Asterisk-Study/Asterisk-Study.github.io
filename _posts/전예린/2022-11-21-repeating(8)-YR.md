---
title: "복습일지(8)"   
layout: post    
comments: true  
categories: [전예린/복습일지]
tags: 트리,이진탐색트리, 그래프, 인접행렬,인접리스트
---

### 221121 || 트리, 그래프

#### 트리

트리 구조는 루트(Root) 라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)으로 연결한다. 
각 데이터를 노드(Node)라고 하며, 여기에 데이터가 담긴다. 두 개의 노드가 상하 계층으로 연결되면 부모/자식 관계를 가진다.

![image](https://user-images.githubusercontent.com/39157466/203002567-5cf1a291-a4c4-4dd7-94d7-1a21ee43e676.png)

-루트 노드(root node) : 부모가 없는 노드, 트리는 하나의 루트 노드만을 가진다.
-단말 노드(leaf node) : 자식이 없는 노드, 말단노드 또는 잎 노드라고도 부른다.
-내부(internal) 노드 : 단말 노드가 아닌 노드
-간선(edge) : 노드를 연결하는 선(link, branch라고도 부름)
-형제(sibling) : 같은 부모를 가지는 노드
-노드의 크기(size) : 자신을 포함하는 모든 자손 노드의 개수
-노드의 깊이(depth) : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
-노드의 레벨(level) : 트리의 특정 깊이를 가지는 노드의 집합
-노드의 차수(degree) : 하위 트리 개수 / 간선 수(degree) = 각 노드가 지닌 가지의 수
-트리의 차수(degree of tree) : 트리의 최대 차수
-트리의 높이(height) : 루트 노드에서 가장 깊숙히 있는 노드의 깊이

트리의 속성 중 가장 중요한 것이 ‘루트노드를 제외한 모든 노드는 단 하나의 부모노드만을 가진다’는 것이다. 이 속성 때문에 트리는 다음 성질을 만족한다.

- 임의의 노드에서 다른 노드로 가는 경로(path)는 유일하다.
- 회로(cycle)가 존재하지 않는다.
- 모든 노드는 서로 연결되어 있다.
- 엣지(edge)를 하나 자르면 트리가 두 개로 분리된다.
- 엣지(edge)의 수 |𝐸| 는 노드의 수 |𝑉|에서 1을 뺀 것과 같다.

<br/>

#### 이진트리

이진 트리(Binary tree)는 자식 노드가 최대 두 개인 노드들로 구성된 트리이다. 이 두 개의 자식 노드는 왼쪽 자식 노드와 오른쪽 자식 노드로 나눌 수 있다.

이진 트리는 자료의 삽입, 삭제 방법에 따라 정 이진 트리(Full binary tree), 완전 이진 트리(Complete binary tree), 포화 이진 트리(Perfect binary tree)로 나뉜다.


<img width="610" alt="스크린샷 2022-11-21 오후 5 40 11" src="https://user-images.githubusercontent.com/39157466/203004231-a8c2e41b-410c-4ae3-ae9d-aaa80ab3b89b.png">


- 정 이진 트리(Full binary tree) : 각 노드가 0개 혹은 2개의 자식 노드를 갖는다.
- 포화 이진 트리(Perfect binary tree) : 정 이진 트리이면서 완전 이진 트리인 경우이다. 모든 리프 노드의 레벨이 동일하고, 모든 레벨이 가득 채워져 있는 트리이다.
- 완전 이진 트리(Complete binary tree) : 마지막 레벨을 제외한 모든 노드가 가득 차 있어야 하고, 마지막 레벨의 노드는 전부 차 있지 않아도 되지만 왼쪽이 채워져야 한다.

<br/>

#### 이진 탐색 트리

이진 탐색 트리(Binary Search Tree)는 모든 왼쪽 자식의 값이 루트나 부모보다 작고, 모든 오른쪽 자식의 값이 루트나 부모보다 큰 값을 가진

이진 탐색 트리의 탐색은 다음과 같은 과정을 거친다.

1. 루트 노드의 키와 찾고자 하는 값을 비교한다. 만약 찾고자 하는 값이라면 탐색을 종료한다.
2. 찾고자 하는 값이 루트 노드의 키보다 작다면 왼쪽 서브 트리로 탐색을 진행한다.
3. 찾고자 하는 값이 루트 노드의 키보다 크다면 오른쪽 서브 트리로 탐색을 진행한다.

특정 목적을 위해 트리의 모든 노드를 한 번씩 방문하는 것을 트리 순회라고 한다. 
트리 구조는 계층적 구조라는 특별한 특징을 가지기 때문에, 모든 노드를 순회하는 방법엔 크게 세 가지가 있다.

트리 구조에서 노드를 순차적으로 조회할 때의 순서는 항상 왼쪽부터 오른쪽이다.

<img width="141" alt="스크린샷 2022-11-21 오후 5 44 34" src="https://user-images.githubusercontent.com/39157466/203005109-2deea830-bfe0-4301-b1d5-ec4b76d5c56b.png">

1. 전위순회

전위 순회에서 가장 먼저 방문하는 노드는 루트이다. 
루트에서 시작해 왼쪽의 노드들을 순차적으로 둘러본 뒤, 왼쪽의 노드 탐색이 끝나면 오른쪽 노드를 탐색을 한다. 
즉 부모 노드가 제일 먼저 방문되는 순회 방식이다. 전위 순회는 주로 부모 노드가 먼저 생성되어야 하는 트리를 복사할 때 사용하게 된다.

위 그림에서의 노드 방문 순서는 1->2->4->5->3이 된다.

2. 중위순회

중위 순회는 루트를 가운데에 두고 순회한다. 
제일 왼쪽 끝에 있는 노드부터 순회하기 시작하여, 루트를 기준으로 왼쪽에 있는 노드의 순회가 끝나면 루트를 거쳐 오른쪽에 있는 노드로 이동하여 마저 탐색한다. 
부모 노드가 서브 트리의 방문 중간에 방문되는 순회 방식이다. 중위 순회는 이진 탐색 트리의 오름차순으로 값을 가져올 때 쓰인다.

위 그림에서의 노드 방문 순서는 4->2->5->1->3이 된다.

3. 후위순회

후위 순회는 루트를 가장 마지막에 순회한다. 
제일 왼쪽 끝에 있는 노드부터 순회하기 시작하여, 루트를 거치지 않고 오른쪽으로 이동해 순회한 뒤, 제일 마지막에 루트를 방문한다. 
후위 순회는 트리를 삭제할 때 사용한다. 자식 노드가 먼저 삭제되어야 상위 노드를 삭제할 수 있기 때문이다.

위 그림에서의 노드 방문 순서는 4->5->2->3->1이 된다.

<br/>

#### 그래프

그래프는 여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현한 자료구조이다. 
자료구조의 그래프는 마치 거미줄처럼 여러 개의 점들이 선으로 이어져 있는 복잡한 네트워크망과 같은 모습을 가지고 있다. 

<img width="426" alt="스크린샷 2022-11-21 오후 5 55 50" src="https://user-images.githubusercontent.com/39157466/203007338-79472d0d-0e64-4b8d-8261-c873b502a1d4.png">
하나의 점을 그래프에서는 정점(vertex)이라고 표현하고, 하나의 선은 간선(edge)이라고 한다.

- 정점 (vertex): 노드(node)라고도 하며 데이터가 저장되는 그래프의 기본 원소이다.
- 간선 (edge): 정점 간의 관계를 나타낸다. (정점을 이어주는 선)
- 인접 정점 (adjacent vertex): 하나의 정점에서 간선에 의해 직접 연결되어 있는 정점을 뜻한다.
- 가중치 그래프 (weighted Graph): 연결의 강도(추가적인 정보, ex. 서울-부산으로 가는 거리 등)가 얼마나 되는지 적혀져 있는 그래프를 뜻한다.
- 비가중치 그래프 (unweighted Graph): 연결의 강도가 적혀져 있지 않는 그래프를 뜻한다.
- 무(방)향 그래프 (undirected graph): 앞서 보았던 내비게이션 예제는 무(방)향 그래프이다. 서울에서 부산으로 갈 수 있듯, 반대로 부산에서 서울로 가는 것도 가능하다. 하지만 단방향(directed) 그래프로 구현된다면 서울에서 부산을 갈 수 있지만, 부산에서 서울로 가는 것은 불가능하다(혹은 그 반대). 만약 두 지점이 일방통행 도로로 이어져 있다면 단방향인 간선으로 표현할 수 있다.
- 진입차수 (in-degree) / 진출차수 (out-degree): 한 정점에 진입(들어오는 간선)하고 진출(나가는 간선)하는 간선이 몇 개인지를 나타낸다.
- 인접 (adjacency): 두 정점 간에 간선이 직접 이어져 있다면 이 두 정점은 인접한 정점이다.
- 자기 루프 (self loop): 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우 자기 루프를 가졌다 라고 표현한다. 다른 정점을 거치지 않는다는 것이 특징이다.
- 사이클 (cycle): 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 사이클이 있다고 표현한다. 내비게이션 그래프는 서울 —> 대전 —> 부산 —> 서울 로 이동이 가능하므로, 사이클이 존재하는 그래프이다.
- 직접적인 관계가 있는 경우 두 점 사이를 이어주는 선이 있다.
- 간접적인 관계라면 몇 개의 점과 선에 걸쳐 이어진다.

<br/>

그래프에는 두 가지 표현 방식이 있다.

1. 인접 행렬

두 정점을 바로 이어주는 간선이 있다면 이 두 정점은 인접하다고 이야기한다. 인접 행렬은 서로 다른 정점들이 인접한 상태인지를 표시한 행렬로 2차원 배열의 형태로 나타낸다.
만약 A라는 정점과 B라는 정점이 이어져 있다면 1(true), 이어져 있지 않다면 0(false)으로 표시한 일종의 표이다. 만약 가중치 그래프라면 1 대신 관계에서 의미 있는 값을 저장한다.

인접행렬은 한 개의 큰 표와 같은 모습을 한 인접 행렬은 두 정점 사이에 관계가 있는지, 없는지 확인하기에 용이하다.
예를 들어, A에서 B로 진출하는 간선이 있는지 파악하기 위해선 0 번째 줄의 1 번째 열에 어떤 값이 저장되어있는지 바로 확인할 수 있다.
가장 빠른 경로(shortest path)를 찾고자 할 때 주로 사용된다.

<img width="280" alt="스크린샷 2022-11-21 오후 5 58 49" src="https://user-images.githubusercontent.com/39157466/203008049-cdbba51e-17fc-4897-81ea-6a373cb2580f.png">

2. 인접 리스트


인접 리스트는 각 정점이 어떤 정점과 인접하는지를 리스트의 형태로 표현한다. 
각 정점마다 하나의 리스트를 가지고 있으며, 이 리스트는 자신과 인접한 다른 정점을 담고 있다. 

인접 리스트는 메모리를 효율적으로 사용하고 싶을 때 인접 리스트를 사용한다.
인접 행렬은 연결 가능한 모든 경우의 수를 저장하기 때문에 상대적으로 메모리를 많이 차지한다.

<img width="530" alt="스크린샷 2022-11-21 오후 5 59 16" src="https://user-images.githubusercontent.com/39157466/203008142-90451374-8a56-454d-bac9-c237b3306995.png">

<br/>

그래프의 탐색은 하나의 정점에서 시작하여 그래프의 모든 정점들을 한 번씩 방문(탐색)하는 것이 목적이다. 그래프의 데이터는 배열처럼 정렬이 되어 있지 않다. 
그래서 원하는 자료를 찾으려면, 하나씩 모두 방문하여 찾아야 힌다.

<br/>

#### BFS

너비를 우선적으로 탐색하는 방법을 Breadth-First Search, 너비 우선 탐색이라고 한다. 
주로 두 정점 사이의 최단 경로를 찾을 때 사용한다. 만약, 경로를 하나씩 전부 방문한다면, 최악의 경우에는 모든 경로를 다 살펴보아야 한다.

#### DFS

깊이를 우선적으로 탐색하는 방법을 Depth-First Search, 깊이 우선 탐색이라고 한다. 한 정점에서 시작해서 다음 경로로 넘어가기 전에 해당 경로를 완벽하게 탐색할 때 사용한다. 
BFS보다 탐색 시간은 조금 오래 걸릴지라도 모든 노드를 완전히 탐색할 수 있다.

