<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | Asterisk</title>
	<meta name="description" content="Asterisk">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<!-- <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"> -->
	<!-- start custom head snippets -->
	<!-- insert favicons. use https://realfavicongenerator.net/ -->
	<link rel="apple-touch-icon" sizes="57x57" href="/assets/favicon.ico/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="/assets/favicon.ico/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/favicon.ico/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="/assets/favicon.ico/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/assets/favicon.ico/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="/assets/favicon.ico/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/assets/favicon.ico/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="/assets/favicon.ico/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon.ico/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192"  href="/assets/favicon.ico/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.ico/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="/assets/favicon.ico/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon.ico/favicon-16x16.png">
	<link rel="manifest" href="/assets/favicon.ico/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="/assets/favicon.ico/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff">


<!-- end custom head snippets -->


	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="Asterisk" href="/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="https://fonts.googleapis.com/css?family=Nanum+Gothic:400,700" rel="stylesheet">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script>
	

	<!-- Google Analytics -->
	
	<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-111748939-1', 'auto');
	ga('send', 'pageview');
	</script>
	
</head>

  <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/asterisk.png" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">Asterisk</a>
		</h1>
		<nav class="site-nav">
				<ul>
					
						
					
						
							<li>
								<a class="page-link" href="/about/">
									About
								</a>
							</li>
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					
						
					

					<!-- Search bar -->
					
					<li>
					<form action="/search.html" method="get">
						<input type="text" id="search-box" name="query" placeholder="Search" class="">
						<button type="submit" class="">
							<i class="fa fa-fw fa-search"></i>
						</button>
					</form>
					</li>
					
				</ul>
		</nav>
	</div>

	<div class="site-category">
			<ul class='cat1'>
				<li><a href="/">Home</a></li>
				<li><a href="/">강진원</a>
					<ul>
							<li><a href="/jw/read">독서일지</a></li>
							<li><a href="/jw/repeat">복습일지</a></li>
							<li><a href="/jw/study">개인공부</a></li>
					</ul>
				</li>

				<li><a href="/">김일태</a>
					<ul>
						<li><a href="/it/read">독서일지</a></li>
						<li><a href="/it/repeat">복습일지</a></li>
						<li><a href="/it/study">개인공부</a></li>
					</ul>
				</li>

				<li><a href="/">윤태연</a>
					<ul>
						<li><a href="/ty/read">독서일지</a></li>
						<li><a href="/ty/repeat">복습일지</a></li>
						<li><a href="/ty/study">개인공부</a></li>
					</ul>
				</li>
				
				<li><a href="/">이영우</a>
					<ul>
						<li><a href="/yw/read">독서일지</a></li>
						<li><a href="/yw/repeat">복습일지</a></li>
						<li><a href="/yw/study">개인공부</a></li>
					</ul>
				</li>

				<li><a href="/">이유정</a>
					<ul>
						<li><a href="/yj/read">독서일지</a></li>
						<li><a href="/yj/repeat">복습일지</a></li>
						<li><a href="/yj/study">개인공부</a></li>
					</ul>
				</li>

				<li><a href="/">이희진</a>
					<ul>
						<li><a href="/hj/read">독서일지</a></li>
						<li><a href="/hj/repeat">복습일지</a></li>
						<li><a href="/hj/study">개인공부</a></li>
					</ul>
				</li>

				<li><a href="/">전예린</a>
					<ul>
						<li><a href="/yr/read">독서일지</a></li>
						<li><a href="/yr/repeat">복습일지</a></li>
						<li><a href="/yr/study">개인공부</a></li>
					</ul>
				</li>

				<li><a href="/">홍동화</a>
					<ul>
						<li><a href="/dh/read">독서일지</a></li>
						<li><a href="/dh/repeat">복습일지</a></li>
						<li><a href="/dh/study">개인공부</a></li>
					</ul>
				</li>

				

				

			</ul>
		</div>

</header>

  <body>
    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
      
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "ea-b9-80-ec-9d-bc-ed-83-9c-eb-b3-b5-ec-8a-b5-ec-9d-bc-ec-a7-80-2022-10-24-review-it-html": {
        "title": "김일태 복습일지",
        "tags": "김일태",
        "date": "October 24, 2022",
        "author": "",
        "category": "",
        "content": "JSON인터넷으로 데이터를 주고받을 때 깔끔한 형식으로 정리한 데이터를 주고 받아야한다.이를 위해 고안된 데이터 담는 형식 중 하나이며 지금 가장 주류라고 생각하면 된다.XML&lt;데이터이름&gt;값&lt;/데이터이름&gt;// EX&lt;삼성전자&gt;50000&lt;/삼성전자&gt;&lt;카카오&gt;100000&lt;/카카오&gt;&lt;food&gt;  &lt;name&gt;Belgian Waffles&lt;/name&gt;  &lt;price&gt;$5.95&lt;/price&gt;  &lt;description&gt; Belgian Waffles &lt;/description&gt;  &lt;calories&gt;650&lt;/calories&gt;&lt;/food&gt;JavaScript 쓰면 object 자료로 쉽게 변환이 가능하지만 작성하기 귀찮고 용량도 많이 잡아먹는다.CSVYear, Brand, Model1997, Ford, E3502000, Mercury, Cougar표 형태를 이루고 있어 데이터베이스에 있던 내용을 CSV로 변환하기 쉽지만, 고차원 데이터는 표현이 어렵다.JSON(JavaScript Object Notation){\"name\" : \"kim\", \"age\" : 20}객체와 비슷한 형식을 가져 고차원 데이터도 표현이 가능하다.객체와 다른 점은 데이터마다 키값을 설정해야 하며 ““로 감싸야 한다.(키 값이 문자 취급)JSON.stringify() // object나 array를 JSON 형식으로 변환JSON.parse() // JSON 형식을 다시 object나 array로 변환DOMdocument.createElementdocument의 createElement 메소드는 지정된 이름의 HTML 요소를 만들어 반환해준다.HTML 요소가 만들어지고 또 반환 되었다고 해서, 해당 요소가 곧장 웹 브라우저 화면에 추가되는 것은 아니다.appendChildappendChild 메소드는 DOM 내 개별 요소(노드)에 자식 요소를 추가할 때 사용하는 메소드이다.appendChild 메소드와 비슷한 역할을 하는 append 메소드도 있다.타겟 요소에 자식 요소를 추가한다는 점에서 같으나, 차이점도 존재한다.주요한 차이  appendChild의 경우 추가한 자식 노드를 반환하지만, append는 반환 데이터가 없다.  append를 이용하면 요소에 노드 객체 또는 문자열을 자식 요소로 추가할 수 있지만, appendChild는 노드 객체만을 추가할 수 있다.입력 요소 값 읽기&lt;input&gt;, &lt;select&gt; 처럼 사용자로부터 입력을 받는 데 사용되는 요소들이 있다. 여기에서 사용자가 입력한 값을 읽어들일 때는 요소의 value 속성에 접근하자.차이를 기억하자  요소의 텍스트에 접근하고 싶다 : textContent 또는 innerText  사용자가 요소에 입력한 값에 접근하고 싶다 : value입력 요소의 value에 접근하여 할 수 있는 일은 크게 두 가지, 읽기와 쓰기이다.console.log(target.value)target.value = '변경값'  &lt;form&gt;    &lt;input type=\"text\" placeholder=\"이름\" name=\"name\" /&gt;    &lt;input type=\"text\" placeholder=\"동네\" name=\"town\" /&gt;    &lt;input type=\"submit\" value=\"PUSH\" /&gt;  &lt;/form&gt;  const form = document.quertSelector(\"form\")    form.addEventListener(\"submit\", function(){    console.log(form.name.value)    console.log(form.town.value)  }) // 이렇게 하면 town만 나옴  const form = document.quertSelector(\"form\")    form.addEventListener(\"submit\", function(){    e.preventDefault() // 리다이렉션 없이 둘 다 출력됨, action 기능을 수행하고 있으면 안해도됨    console.log(form.name.value)    console.log(form.town.value)  })form에서 이벤트가 제출되는 submit 이벤트가 발생하면 action 속성의 url로 리다이렉트되지만, 이벤트 객체를 통해 기본 기능을 차단할 수 있다.",
        "url": "//%EA%B9%80%EC%9D%BC%ED%83%9C/%EB%B3%B5%EC%8A%B5%EC%9D%BC%EC%A7%80/2022/10/24/Review-IT.html"
      }
      ,
    
      "ea-b9-80-ec-9d-bc-ed-83-9c-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-24-deep-dive-reading-it-html": {
        "title": "김일태 독서일지 : 모던 자바스크립트 Deep Dive",
        "tags": "김일태",
        "date": "October 24, 2022",
        "author": "",
        "category": "",
        "content": "1장. 프로그래밍프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것2장. 자바스크립트란?렌더링이란 HTML, CSS, 자바스크립트로 작성된 문서를 해석해서 브라우저에 시각적으로 출력하는 것을 말함, 때로는 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정(SSR:Service Side Rendering)을 가리키도 함Ajax는 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식을 가능하게 함jQuery의 등장으로 다소 번거롭고 논란이 있던 DOM을 더욱 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결됨…..…..4장. 변수자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름이다.일반적으로 초기화란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행된다. 따라서 var 키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다.변순 선언이 소스코드 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행한다. 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징을 변수 호이스팅이라 한다. 변수 선언뿐 아니라 모든 식별자(변수, 함수, 클래스 등)는 호이스팅한다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. - 매니지드 언어 - 메모리 누수 방지5장. 표현식과 문리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. - 완료값크롬 개발자 도구에서 표현식인 문은 평가된 값을 반환한다.6장. 데이터 타입데이터 타입이 필요한 이유  값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해서  값을 참조할 때 한 번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해서  메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해서자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 변할 수 있다. 이러한 특징을 동적 타이핑이라 한다.동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.7장. 연산자증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.증가/감소(++/–) 연산자는 위치에 의미가 있다.  피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.  피연산자 뒤에 위치한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 부수 효과는 없다.암묵적 타입 변환 // 타입 강제 변환NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN을 사용한다.Object.is 메소드는 일치 비교 연산자(===)와 비슷하게 작동하며 NaN 두 개를 비교하면 true를 반환하고 +0과 -0을 비교하면 false를 반환하는 더 예측 가능한 결과를 반환한다.드 모르간의 법칙논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한눈에 이해하기 어려울 때가 있다. 이러한 경우 드 모르간의 법칙을 활용하면 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환할 수 있다.                              !(x                     y) = (!x &amp;&amp; !y)                                                  !(x &amp;&amp; y) = (!x                     !y)                    typeof 연산자로 null 값을 연산해보면 “null”이 아닌 “object”를 반환한다는 데 주의하자. 이것은 자바스크립트의 첫 번째 버전의 버그다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다. 또 하나 주의해야 할 것이 있다. 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 undefined를 반환한다.ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다. 지수 연산자가 도입되기 이전에는 Math.pow 메서드를 사용했다. 음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 한다.대부분의 연산자는 다른 코드에 영향을 주지 않는다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다. 부수 효과가 있는 연산자는 할당 연산자(=), 증가/감소 연산자(++/–), delete 연산자다.",
        "url": "//%EA%B9%80%EC%9D%BC%ED%83%9C/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/24/Deep-Dive-Reading-IT.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-23-repeating-ssr-vs-csr-html": {
        "title": "윤태연 복습일지(3)",
        "tags": "윤태연",
        "date": "October 23, 2022",
        "author": "",
        "category": "",
        "content": "SSR vs CSR: 2022 / 10 / 24정의SSR과 CSR은 렌더링이 어디에 일어나냐의 방식 차이로 SSR은 서버에서, CSR은 파일을 받아 클라이언트에서 렌더링된다.특성 및 차이점SSR은 요청마다 로딩이 되는 특징이 있어 첫 요청에 관한 로딩은 빠르지만 요청(페이지 전환)마다 첫 요청이 해왔던 과정 그대로 반복해 렌더링하기에 1. 서버 부하가 커지고, 2. EX에 부정적 영향CSR은 첫 요청에만 전체 JS, HTML파일을 받아와 클라이언트에서 실행되기에 첫 로딩은 느리지만 1. 그 다음 요청들은 빨라 SSR과 반대로 로딩이 짧아 EX에 긍정적인 영향을 주지만 2. 파일의 규모가 클 경우 첫 로딩이 더욱 길어지고 3. 각 페이지 마다 meta 데이터가 없기에 SEO에 취약하다.결론은 각 특징을 잘 알고 상황마다 렌더링 방식에 차이를 둬야할 것이다.  SSR을 써야할 경우: 서버가 안좋거나, 네트워크가 느리거나, 웹 앱의 상호작용이 비교적 적을 때, 메인 스크립트가 매우 클 때, SEO가 중요할 때  CSR을 써야할 경우: SSR과 반대, 서버 좋, 넷월ㅋ 빠름, 상호작용이 많을 수록 CSR, 메인 스크립트가 작을 때, SEO 따위 필요 없을 때, 중간 요청의 파일 크기가 매우 클 때(로딩을 넣을 수 있어서)+ 추가로 요즘 검색 엔진 중에서도 JS을 읽어낼 수 있는 엔진도 존재해 CSR의 단점이 보완되고 있음",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/23/repeating-ssr_vs_csr.html"
      }
      ,
    
      "ea-b9-80-ec-9d-bc-ed-83-9c-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-23-deep-dive-reading-it-html": {
        "title": "김일태 독서일지 : 모던 자바스크립트 Deep Dive",
        "tags": "김일태",
        "date": "October 23, 2022",
        "author": "",
        "category": "",
        "content": "1장. 프로그래밍프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것2장. 자바스크립트란?렌더링이란 HTML, CSS, 자바스크립트로 작성된 문서를 해석해서 브라우저에 시각적으로 출력하는 것을 말함, 때로는 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정(SSR:Service Side Rendering)을 가리키도 함Ajax는 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식을 가능하게 함jQuery의 등장으로 다소 번거롭고 논란이 있던 DOM을 더욱 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결됨…..…..4장. 변수자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름이다.일반적으로 초기화란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행된다. 따라서 var 키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다.변순 선언이 소스코드 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행한다. 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징을 변수 호이스팅이라 한다. 변수 선언뿐 아니라 모든 식별자(변수, 함수, 클래스 등)는 호이스팅한다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. - 매니지드 언어 - 메모리 누수 방지리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. - 완료값크롬 개발자 도구에서 표현식인 문은 평가된 값을 반환한다.데이터 타입이 필요한 이유  값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해서  값을 참조할 때 한 번에 읽어들여야 할 메모리 공간의 크기를 결정하기 위해서  메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해서자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 변할 수 있다. 이러한 특징을 동적 타이핑이라 한다.동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.",
        "url": "//%EA%B9%80%EC%9D%BC%ED%83%9C/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/23/Deep-Dive-Reading-IT.html"
      }
      ,
    
      "ec-9d-b4-ed-9d-ac-ec-a7-84-eb-b3-b5-ec-8a-b5-ec-9d-bc-ec-a7-80-2022-10-22-repeating-hj-html": {
        "title": "이희진 복습일지",
        "tags": "",
        "date": "October 22, 2022",
        "author": "",
        "category": "",
        "content": "221011 || URI vs URLURI는 URL를 포함하는 상위개념이라 하나 둘의 차이가 명확하게 와닿지는 않는다.이 둘의 명확한 구분을 위해 좀 더 상세히 살펴보면 다음과 같다.먼저 URI는 통합 자원 식별자(Uniform Resource Identifier)의 약자로 논리적 및 물리적 리소스를 식별하는 고유한 문자열 시퀸스다.그럼 URL은 무엇일까? 통합 자원 위치 탐사기(Uniform Resource Locator)로 네트워크 상에서 리소스가 어디에 있는지 알려주는 규약이다.요약하면 URI는 식별을 하고 URL는 위치까지 가르킨다. 그렇기 때문에 URI이더라도 위치 정보가 없다면 URL이 될 수 없으므로 ‘URL은 URI이다’는 성립이 되지만 ‘URI는 URL이다’는 성립이 되지 못한다.즉, 한 가지 예를 들어 설명하면 다음과 같다.http://asterisk.com/user?id=123이 경우, ‘?id=123(query)’의 결과에 따라 특정 자원의 결과가 다르게 나올 수 있으므로 이를 식별자라 한다. 즉, 식별자 이전까지는 URL이라 할 수 있으나 식별자가 붙은 형태는 URL이라 할 수 없고 오로지 URI라고만 할 수 있다.221016 || express 라이브러리express.js로 서버를 여는 건 어쩌면 node.js보다 간단할 수 있다. 그럼 express 라이브러리 설치 후 실행을 시키는 건 어떤 과정을 거칠까.const express = require('express');const app = express();app.listen(port, function(){실행할 코드});이게 하나의 기본 양식이다. 아래의 listen()을 통해 서버를 열 수 있는데 listen()에는 총 두 개의 인자가 들어간다. 하나는 서버를 띄울 포트, 하나는 서버를 열고 실행할 코드로 완성한다면 해당 포트로 접속했을 때 사용자가 마주할 페이지를 마음대로 설정할 수 있다. 또한 여기서 멈추지 않고 서버를 띄웠을 때 서버로 오는 다양한 요청들을 처리할 수 있어야 한다. 가장 보편적인 예로 사용자가 URL을 통해 GET 요청을 보냈을 때 요청에 맞춰 페이지 응답을 보낼 수 있어야 하는 것이다.app.get( '경로', function(req, res){   res.send('전달인자로 받은 경로로 접속했을 때 실행할 코드);   }만약 ‘/books’라는 경로에 도달했을 때 다양한 책의 목록이 나오는 페이지를 띄우고 싶다면 res.send()안에 원하는 페이지를 띄우는 코드를 작성하면 된다. 이것이 기본적인 express 라이브러리를 실행하는 틀이며 다양한 활용을 통해 동적인 페이지를 구성할 수 있다.221022 || DOM(1)DOM은 정확히 무엇일까? 브라우저 렌더링 엔진이 HTML 문서를 파싱(일련의 문자열을 token 단위로 분해해 parse tree을 생성)하여 만든 자료 구조를 DOM이라 한다. HTML 요소들(태그, 어트리뷰트 이름 및 값, 콘텐츠)은 파싱을 통해 요소 노드 객체(요소 노드, 어트리뷰트 노드, 텍스트 노드)로 변환된다.HTML 요소 간에는 중첩 관계가 있기 때문에 이 사이엔 부모-자식 관계가 형성이 되고 이를 기반으로 비선형(하나의 자료 뒤에 여러 개의 자료가 존재함) 자료구조 중 하나인 트리 자료구조가 생성된다.파싱을 통해 형성된 DOM의 노드 객체는 총 12개가 있으며 이 중 중요한 노드 타입은 총 4개 있다.      문서 노드(Document node)DOM 트리의 최상위에 존재하는 루트 노드인 document 객체를 의미한다. window.document 또는 document로 참조 가능하며 이때 window 객체는 하나의 전역 객체라 모든 자바 스크립트 코드가 공유하고 window의 document 프로퍼티에 바인딩 되어 있는 하나의 document 객체를 보게 된다. 따라서, HTML 문서당 window 객체는 유일하다. 문서 노드는 앞서 말했듯 루트 노드이기 때문에 요소, 어트리뷰트, 텍스트 등 다른 노드에 접근하기 위해서는 문서 노드를 꼭 거쳐야 한다. 이러한 특징 때문에 문서 노드는 진입점 역할을 담당한다 할 수 있다.        요소 노드(Element node)HTML 요소를 가리키는 객체로 해당 노드는 다른 노드와 부모-자식 관계를 가질 수 있고 이 관계를 통해 구조(트리 구조)화가 가능하다. 이 때문에 요소 노드는 문서의 구조를 표현한다고 할 수 있다.        어트리뷰트 노드(attribute node)어트리뷰트 노드는 HTML 요소의 어트리뷰트를 가리키는 객체로 해당 노드에 접근하기 위해서는 요소 노드에 먼저 접근해야 한다. 이는 어트리뷰트 노드가 오로지 요소 노드에만 연결되어 있기 때문이다. 단, 여기서 주의해야 하는 것은 해당 연결은 상위로 연결된 게 아니라 동등한 위치에서 연결된 것으로 요소 노드와 어트리뷰트 노드의 관계는 부모-자식이라 할 수 없다.        텍스트 노드(Text node)HTML 요소의 텍스트를 가리키는 객체로 요소 노드가 문서의 구조라면 텍스트 노드는 문서의 내용을 의미한다. 텍스트 노드는 요소 노드의 자식 노드로 접근하기 위해선 요소 노드에 먼저 접근해야 하며 텍스트 노드는 본인의 자식 노드를 가질 수 없는 리프 노드다. 즉, DOM 트리의 최종단이라 할 수 있다.  ",
        "url": "//%EC%9D%B4%ED%9D%AC%EC%A7%84/%EB%B3%B5%EC%8A%B5%EC%9D%BC%EC%A7%80/2022/10/22/repeating-HJ.html"
      }
      ,
    
      "ec-9d-b4-ec-98-81-ec-9a-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-22-reading-4-yw-html": {
        "title": "이영우 독서일지(4)",
        "tags": "",
        "date": "October 22, 2022",
        "author": "",
        "category": "",
        "content": "5일차 35p ~ 42p 이름은 어디에서나 쓰이기 때문에 잘 짓는것이 중요하다.에 대한 추가내용.함수에 대한 내용 시작.",
        "url": "//%EC%9D%B4%EC%98%81%EC%9A%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/22/reading(4)-YW.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-22-ec-98-a4-ea-b0-9c-ec-95-88-eb-a7-907-html": {
        "title": "윤태연 독서일지: 오개안말(7)",
        "tags": "윤태연",
        "date": "October 22, 2022",
        "author": "",
        "category": "",
        "content": "디자이너의 마인드셋: 2022 / 10 / 22Part3. 디자이너의 일1. 디자이너의 마인드셋IT기업의 디자이너는 생각한대로 디자인하는 것이 아닌 기획의 의도나 목적을 중점으로 디자인해야한다. 예술이 아니라 주어진 목적을 조형적으로 실체화해야한다. 왜!? 미적 기준은 사람마다 달라 통일할 수 없으며 각 기능, 페이지의 목적마다 중점적으로 둬야하는 포인트가 다르기에 기획안을 기준으로 디자인해야한다.  웹/앱 디자인의 핵심: UI/UX - 사용자 중심의 경험이 중요하다!예: 하인즈 이전 케찹들은 뚜껑이 위로 가게 UI가 디자인 됐다. 하지만 UX적인 관점에서 케챱이 뚜껑과 반대로 있다면 케챱이 뚜껑에 뭉치는 등 별로였다. 하인즈 케찹은 UI를 뚜껑 아래로 가게 만들어 짜기 편하게(내용물 적어져도, 뚜껑 안굳음)만들어 UX를 향상시켰다!  UI/UX 관련 개발 방법: 사용자 중심, 편한 지 안편한지          구글 애널리틱스 툴: 기획, 개발 등 대부분 도움되는 툴, 신규 방문, 재방문 등과 어느 페이지에서 이탈률이 높은지 분석해주는 툴, 이 걸 기준으로 디자인하면 좋음      툴, 구조 등을 분석하는 것이 디자이너 하나만 하기엔 버거워서 협업 필요        디자이너로서 경쟁력 갖추기: 감각 늘려 트렌드 잡기, 개발 구조 이해          감각 늘리기, 트렌드 잡기: 다양한 레퍼런스 관찰(드리블, 핀터레스트, Muzli 등), 트렌디한 툴 사용(피그마, 스케치, 제플린 등)      개발을 아는 디자이너는 치명적!: 기초 퍼블리싱 지식을 익혀둬 가능, 불가능 기능들을 디자인해 효율적인 디자인을 하자. 그 이상 개발을 하고싶고 한다면 프리랜서로 하는게 더 효율적      ",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/22/%EC%98%A4%EA%B0%9C%EC%95%88%EB%A7%907.html"
      }
      ,
    
      "ec-a0-84-ec-98-88-eb-a6-b0-eb-b3-b5-ec-8a-b5-ec-9d-bc-ec-a7-80-2022-10-21-reapeating-3-yr-html": {
        "title": "전예린 복습일지(3)",
        "tags": "",
        "date": "October 21, 2022",
        "author": "",
        "category": "",
        "content": "221017 || request 프로퍼티 : req.body() / query() / params()의 차이Express로 서버를 구현 할 때, request의 프로퍼티들을 사용하여 우리가 원하는 값을 불러온다.대표적인 request 프로퍼티인 req.body() / query() / params()의 차이점에 대해 알아보자.  req.params()라우트 파라미터들을 포함한다.만약 요청온 url이 www.example.com/public/100/jun 이라면,router.get('/:id/:name', (req, res, next) =&gt; {  console.log(req.params) // { id: '100', name: 'jun' }});req.params 값은 { id: ‘100’, name: ‘jun’ } 이 된다.  req. query()url 쿼리 파라미터들을 포함하며, 주로 GET 요청을 처리할 때 사용한다.만약 요청온 url이 www.example.com/public/100/jun?title=hello! 이라면,router.get('/:id/:name', (req, res, next) =&gt; {  console.log(req.query) // { title : 'hello!' }});req.query 값은 { title : ‘hello!’ } 이 된다.  req.body()주로 POST/PUT 요청을 처리할 때, 유저 정보 등의 JSON 바디 데이터를 담을 때 사용한다.클라이언트에서 다음과 같이 요청을 보내면,await axios({  method: \"post\",  url: `www.example.com/post/1/jun`,  data: { // post 로 보낼 데이터    name: 'nomad',    age: 11,    married: true  },})req.body는 { name: ‘nomad’, age: 11, married: true }가 된다.router.post('/:id/:name', (req, res, next) =&gt; {// post 요청 시 담은 객체 부분이 담긴다.  console.log(req.body) // { name: 'nomad', age: 11, married: true }});",
        "url": "//%EC%A0%84%EC%98%88%EB%A6%B0/%EB%B3%B5%EC%8A%B5%EC%9D%BC%EC%A7%80/2022/10/21/reapeating(3)-YR.html"
      }
      ,
    
      "ec-a0-84-ec-98-88-eb-a6-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-20-reading-3-yr-html": {
        "title": "전예린 독서일지(3): 커리어 스킬",
        "tags": "",
        "date": "October 20, 2022",
        "author": "",
        "category": "",
        "content": "22.10.18 화요일 182p~189p이력서 || 직접 작성하는 방향이력서의 초점을 자신이 무엇을 원하느냐가 아니라 자신이 어떤 가치를 제공하느냐에 맞춰라. 이력서에 그 일자리를 얻었을 때 무슨 일을 하고 싶은지, 자신이 얼마나 훌륭한 사람인지 자랑할 필요가 없다.현재 가지고 있는 기술과 과거에 쌓은 업적을 기반으로 자신이 장래의 고용주에게 어떠한 가치를 제공할 수 있는지 보여주어야 한다.각 회사에 맞게 이력서를 수정하여 그 회사에 맞는 특별한 가치를 제공할 능력을 보여주자.자신이 한 일을 적을 때는 다음 세 가지 정보를 넣어서 구체적으로 써라.  자신이 한 업무  그 업무를 수행한 방법  자신이 얻은 결과이력서는 1페이지로 작성하라. 어떤 소프트웨어 개발자이고 어떤 관련 경력과 기술을 갖추고 있는지 핵심 정보를 빠르게 알아볼 수 있게 하라.이력서 교정은 최소 5번 이상 봐야 한다. 이력서에 남아 있는 오타나 문법 오류, 맞춤법 오류는 이력서의 주인공이 멍청하고 부주의하고 세부적인 것까지 관심을 기울이지 않는다고 광고하는 최고의 방법이다. 특히 맞춤법 오류가 그렇다.여러 종류의 일자리에 지원하려면 이력서의 기본 버전 또한 여러 종류로 만들어야 한다. 이력서를 창의적이고 독특하게 하되, 주의를 분산시켜 메세지를 약화하지 말고, 메세지를 강화하는 쪽으로 사용하라.22.10.19 수요일 190p~196p면접 절차 || 면접 유형표준 기술 면접)면접을 어떻게 보아야 할지 모르는 개발자가 면접을 맡는 일이 흔하다. 면접관은 아마 지원자가 쓸 핵심 기술이나 프로그래밍 언어에 관한 면접용 질문을 구글에서 검색해보고 들어올 것이다.지원자도 똑같은 방법으로 면접을 준비하면 된다. 면접에 들어가기 전에 자신이 선택한 기술에 관한 면접 질문과 답을 구글에서 검색해 알아두자. 인성 면접)이 유형의 면접은 보통 관리자가 본다. 작은 회사라면 CEO나 회사 창업자가 보기도 한다. 최대한 자연스럽게 행동하고 반사회적인 행동은 삼가라.패널 면접)패널 면접은 일렬로 앉은 여러 패널을 상대로 보는 면접이다. 기술 관련 질문과 사적인 질문을 던지고 지원자의 답변을 자세히 받아 적는다. 패널 면접은 모든 면접의 마지막이자 최종 관문인 경우가 많으므로 잘 준비하는게 좋다.코딩 면접)이 유형의 문제 해결을 위해 아예 새로운 사고방식이나 접근법을 익혀두어야 한다. 문제를 수도 코드로 나누고 이를 다시 IDE로 옮겨서 최종 해결책을 구현해라. 연습하고 연습하는게 답이다.22.10.20 목요일 197p~206p면접 절차 || 면접을 대비해 알아두어야 할 것코딩 문제 푸는 법)코딩 면접을 잘 통과하는 방법에 대해 쓴 블로그 포스트나 구직 면접 준비하기를 주제로 한 플루럴 사이트 강의를 참고해도 좋다. 알고리즘 문제를 분해해서 해결하는 방법을 단계별로 보여주는 강의다.기술에 대한 일반적인 질문)자신의 전문 분야는 제대로 알아야 한다. 적어도 구글에서 ‘자신이 선택한 기술 + 면접 질문’을 검색해 나온 상위 세 가지 검색 결과에 해당하는 모든 질문에 대답할 수 있도록 준비해라.예를 들어, 객체지향적인 프로그래밍 언어와 관련된 면접에 들어간다면 적어도 캡슐화, 상속, 다형성, 데이터 추상화, 인터페이스, 추상 기본 클래스에 대해서는 알아야 한다.성격에 관한 질문과 심리학적 질문)일반적인 성격 관련 질문이나 심리 관련 질문에 답할 수 있게 준비를 해두자. 세부적인 약점을 너무 많이 노출하지 않는 선에서 최대한 진실되게 답하되 긍적적인 태도를 견지하라.책임감 있는 모습, 성장하는 모습을 보여라. 어떤 상황에서도 남을 탓하지 마라. 약점의 긍정적인 면을 찾아내서 강조한 후 가볍게 약점을 언급하며 마쳐라. 어떻게 약점을 강점으로 승화시킬 수 있는지 보여줘라.면접 팁  면접을 보러 갈 때는 그 회사의 표준 복식 규정보다 두 단계 높은 의상을 선택하라.  정시 지키기. 30분 전에 도착하라.  거짓말하지 마라. 기술 관련 질문에서 답을 모르면 모른다고 얘기하고 집에 가서라도 찾아보겠다고 말하라. 면접관이 던진 질문의 답을 반드시 전부 알아야 하는 건 아니다. 자신의 지식에 부족한 부분이 있다는 사실을 솔직하고 겸손하게 인정하고 결점을 채우기 위해 노력하는 모습을 보이는 게 대충 둘러대고 거짓말 하는 것보다 훨씬 더 좋은 인상을 남긴다.답을 모른다고 인정할 질문이 하나 정도 있는 건 오히려 도움이 될 때도 있다  방어적인 태도를 취하지 마라. 면접 중에 공격을 받는다고 느껴도 그 상황을 견뎌라. 자신이 자신감을 가질 만한 실력을 갖추었다고 믿어라.  자세히 말해라. 한 단어나 한 문장으로 답하지 마라. 항상 정성 들여 답하라.  자신감을 가져라. 면접을 철저히 준비할수록 자신감이 생긴다. 어려운 부분을 잘 대비해라.  자신이 면접에서 하는 모든 말에 이 메세지를 담아라. 이게 가장 중요한 특성이니 이를 가능한 많은 방법으로 증명할 방법을 찾아라. 기회가 된다면 말로도 꼭 해라.          저는 능동적인 사람입니다. 해야 할 일이 무엇인지 스스로 파악하고 실행합니다.        연습에 도움이 되는 일이라면 무엇이든 해라. 자신의 모습을 동영상으로 찍어보라.",
        "url": "//%EC%A0%84%EC%98%88%EB%A6%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/20/reading(3)-YR.html"
      }
      ,
    
      "ec-9d-b4-ec-9c-a0-ec-a0-95-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-19-reading-2-yj-html": {
        "title": "이유정 독서일지(2장): 전자 회로의 조합 논리",
        "tags": "",
        "date": "October 19, 2022",
        "author": "",
        "category": "",
        "content": "20221019 수요일 p.91 ~ p.96 반이번 장에서는 전기 분야의 혁신을 이끌어낸 변화에 대해 말해보자 . 비트를 사용하지 않는 초기 계산 장치를 살펴봄으로써 왜 비트가 오늘날 사용하는 기술에 어울리는 올바른 선택인지 배운다. 비트를 만들기 위해 무엇이 필요할까 릴레이나 진공관 같은 더 오래되고 단순한 기술을 살펴보고, 이런 기술을 전기와 집적 회로를 사용하는 하드웨어를 통한 현대적인 비트 구현과 비교해보자 /비트에 대해 동작하는 장치를 포함해 모든 물리적인 장치를 하드웨어라고 부른다. 우리는 조합 논리를 구현하는 하드웨어에 대해 살펴볼 것이다. 조합논리는 불리언 대수의 또 다른 이름이다. /디지털 컴퓨터의 사례 : 톱니바퀴의 톱니 비율이 상대적인 회전 속도를 결정하기 때문에 곱셈, 나눗셈, 기타 계산에 톱니바퀴가 유용하다. 안티키테라 기계는 사용자가 다이얼을 돌려서 날짜를 이비력하고 크랭크를 돌려서 천문학 계산을 수행한다. 또, 화기 제어 컴퓨터는 톱니바퀴를 이용해 삼각함수와 미적분을 계산한 예술품이다 ㅋㅋ! / 톱니바퀴를 사용하지 않는 기계식 컴퓨터로는 계산자가 있다. 로그를 영리하게 응용한 도구다. 일상적으로 큰 수를 곱해야 하는 중세 천문학자나 엔지니어에게 엄청난 도구였다. 계산자는 대량 생산된 계산 장치로 여겨지며, 비행 컴퓨터라고 부르는 동그란 꼐산자를 비상용 항법 계산 도구로 사용한다. / 역사적으로 계수가 계산 장치를 활용하는 주된 용도였다. 손가락이 열개밖에 없기 때문에 탤리 막대를 사용했었다. / 복잡한 10진 기계식 계산기 개발 비용인 차분 기관은 부품의 정밀도가 배비지 시대의 금속 가공 기술로는 달성할 수 없었다. 하지만 간단한 기계적 10진수 계산기는 차분 기관 같은 복잡한 금속 기술이 필요하지 않았기 때문에 1600년대에 만들어졌고, 여러 다른 모델이 대량 생산됐고 후기 모델은 손으로 돌리는 핸들을 전동 모터로 바꿨다. / 아날로그와 디지털 차이! : 계산자는 연속적이고 손가락은 이산적이다. 연속적이라는 말은 실수를 표현할 수 있다는 뜻이고, 이산적이라는 말은 정수만 표현할 수 있다. 전자기술에 대해 이야기 할 때 아날로그는 연속적인 것을 뜻하고, 디지털은 이산적인 것을 뜻한다. 손가락이 라틴어로 digitus 다. 한편, 실수를 표현할 수 있기 때문에 아날로그가 계산에는 더 적합한 것 같지만 정밀도의문제가 있다. 이를 해결하기 위해 자를 더 크게 만들 수 잇으나, 큰 물건을 움직이는 데 엄청난 에너지가 필요하고, 우리는 작고 빠르면서전력 소모가 적은 컴퓨터를 원한다. / 하드웨어에서 크기가 중요한 이유 : 현대 컴퓨터는 전자를 움직인다. 전기는 빛의 속도로 움직이며 빛의 속도는 초당 3억 미터다. 이런 물리적인 한계를 뛰어넘는 방법을 아직 발견하지 못했기 때문에 부품을 가능한 한 가깝게 위치시킨다. 40억 분의 1초 동안 이동할 수 있는 거리는 75 밀리미터 뿐이다. 전형적인 cpu는 한 면 이 18밀리미터다. 40억분의 1초는 전자가 이 cpu 안을 겨우 두번 왕복할 수 있는 정도의 시간이다. 컴퓨터에서 모든 것을 작게 만들면 더 높은 성능을 달성할 수 있겠죠? 거리가 줄어들면 써야할 에너지가 줄어들며 이는 저 전력 소모와 열 발생 감소로 이어진다. 하지만 하드웨어를 작게 만들다 보니, 여러 가지 문제가 생겼다.2022-10-20 목요일 p.96반 ~ 100 반디지털을 사용하면 더 안정적인 장치를 만들 수 있다하드웨어를 작게 만들면 속도와 효율은 좋아지지만, 물체가 너무 작아지면 서로 간섭하기 쉬워진다. 예를들어 계량컵이 너무 작으면 원자의 운동으로 컵이 흔들린다. 계량컵과 계산자는 모두 아날로그 장치로, 정확하게 값을 읽으려면 흔들림이 없어야 한다. 하지만 손가락이나 탤리 막대, 기계식 계산기 같은 디티털, 이산적인 장치에 영향을 끼치기는 어렵다. 왜냐하면 이산적인 장치는 판정 기준이 있기 때문이다. 결과적으로 판정 기준을 도입하면 값 중에 어떤 범위의 값을 표현할 수 있는 가능성이 사라진다. 현대 cpu에서 신호 간섭은 마치 도로에서 마주 보는 두 차가 서로 스쳐 지나갈 때 느껴지는 바람과 같다. 이런 누화 효과를 방지할 적절한 방법이 없기 때문에 더 높은 판정 기준을 통해 잡음 내성을 갖는 디지털 회로를 사용하는 것이 필수적이다. 판정 기준이라는 장애물을 뛰어넘기 위해서는 추가로 에너지가 필요하기 때문에 연속적인 장치를 사용할 때는 얻을 수 없는 일정 수준의 잡음 내성을 얻을 수 있다. 실제로 판정 기준을 도입해 생기는 안정성이 우리가 디지털 컴퓨터를 만드는 주된 이유다.아날로그 세계에서 디지털 만들기자연적으로 발생하는 전이 함수에 대해 설명해볼게요. 전이함수의 x축은 들어오는 빛의 양을 뜻하며 y축은 기록되는 밝기나 센서가 기록하는 빛을 의미한다. 빛의 값이 다르면 전이 함수가 기록하는 빛의 값도 달라진다. 전이함수는 곡선인것에 집중하자. 빛이 곡선의 상단부에 많이 닿으면 밝기 값이 서로 모이면서 이미지 노출이 과해지고 , 하단부에 많이 닿으면 이미지 노출이 부족해진다. 카메라 경우, 노출을 조절해서 빛이 직선부에 많이 닿게 만드는 것이다. 전이함수를 이용해 빛이 선형 영역에 닿게 하기 위해 ㅅ카메라의 셔터 속도나 조리개를 조절하는 장치도 만들었고, 증폭 회로도 전이함수를 이용했다. 볼륨은 게인이나 곡선이 가파른 정도를 조절한다. 게인이 높으면 곡선이 가팔라지고 출력도 커진다. 만약 게인이 11이라면? 왜곡이 발생하고 소리가 이상해진다. 입력이 조금만 변해도 곡선의 가파른 부분 때문에 출력이 확 달라진다. 이때 판정 기준을 문턱값이라고 한다. 출력값이 문턱값의 한쪽에서 반대쪽으로 옮겨가고 중간 정도의 출력값이 나오기는 어렵기 때문에 이런 왜곡이 유용하다. 이 현상은 연속적인 공간을 이산적인 영역으로 나눠준다. 즉, 아날로그는 가능한 한 선형 영역을 크케 만들고, 디지털은 직선부를 가능하면 작게 만드는 것이라고 할 수 있다.2022-10-23 일요일 p.100 반 ~p. 105 반10진 숫자 대신 비트를 사용하는 이유한 손가락이 한 숫자를 표현하기 때문에 효율적이지 않다. 손가락 대신 비트를 사용하면 100배 더 효율이 좋아진다. 또, 숫자를 이용하면 전이 함수를 각기 다른 10가지 문턱값으로 구분할 수 있는 간단한 방법이 없기 때문이다. 만들더라고 복잡하고 비용이 많이 든다. 즉, 10진 숫자 하나보다는 10비트를 사용하는게 훨 좋다. 이것이 현대적 하드웨어가 작동하는 방식이다. 우리는 전이 함수의 하단부와 상단부 영역을 활용하며, 하단부 영역을 차단, 상단부 영역을 포화라고 한다. 비트를 사용하면 재량권이 아주 커진다. 전이 함수가 아주 가파르기 때문에 출력이 한 값에서 다른 값으로 아주 급하게 바뀐다.간단한 전기 이론 가이드현대 컴퓨터는 전기를 조작해 작동된다. 전기를 사용해 컴퓨터를 만들면 더 빠르고 쉽게 만들 수 있다. 컴퓨터 하드웨어에서 전기를 사용하는 방법을 이해하도록 돕겠다.전기는 수도 배관과 비슷하다.전기를 물이라고 생각해보자. 물이 물탱크에서 나오는 것처럼 전기는 배터리 같은 에너지 근원에서 나온다. 우리가 사용할 수 잇는 유일한 큰 에너지 근원은 태양뿐이다. 태양에서 온 에너지가 물을 기화시켜 수증기로 만들고, 수증기는 다시 물이 되어 물탱크를 채운다. 우리는 0이 밸브가 닫힌 상태를, 1이 밸브가 열린 상태를 표현한다고 가정한다. 직렬연결은 AND 연산을 구현하고, 병렬 연결은 OR 연산을 구현한다. 물이 파이프로 흘러서 전달되는 데 시간이 걸리는 것처럼, 전기가 컴퓨터 칩 내부에서 전파되는 데도 시간이 걸린다. 물 온도가 따뜻해지기 까지 시간이 걸리는 것처럼 전파지연도 있다. 이런 지연은 상수가 아니다. 물의 경우 온도 변화가 파이프를 확장시키거나 수축시키기 때문에 물의 흐름이 달라지며 그에 따라 지연 시간도 달라진다. 물이 파이프를 흘러가는 것처럼 전기도 선을 통해 이동한다. 다만ㅇ 이런 전기의 이동은 실제로는 전자의 흐름은 아니고 전자기 에너지 반응이 전파되는 현상을 전기라고 불렀다. 내부에 있는 금속을 도체라고 부르고 금속 바깥쪽을 둘러싼 부분을 부도체라고 부른다. 도체는 파이프 내부, 부도체는 파이프 자체라고 할 수 있다. 전기의 흐름을 제어할 수 있는 밸브를 스위치라고 부른다. 물은 압력에 의해 밀려서 움직인다. 압력의 세기는 달라질 수 있다. 전기에서 수압에 해당하는 존재는 전압이며 측정 단위는 볼트다. 전기 흐름의 양은 전류고 측정 단위는 암페어다. 관이 더 가늘수록 관을 통해 흐를 수 있는 물의 양을 제한하는 저항이 더 커진다. 전압이 더 높더라도 너무 가는 도체를 사용함으로 인해 저항이 아주 크면 전류가 커지지 못한다. 저항을 측정할 때는 옴을 쓴다. 이 세가지 변수 전압, 전류, 저항은 옴의 법칙을 통해 전류는 전압을 저항으로 나눈 값과 같다. 저항이 크면 전류가 더 줄어든다. 게다가 저항은 전기를 열로 바꾼다. 이 원리를 이용해 토스터부터 전기담요까지 모든 전열기구가 작동한다.복습일지const root = document.getElementById('root');function createTreeView(menu, currentNode) {  menu.map(el=&gt; {    const liElement = document.createElement('li')    currentNode.append(liElement)    if(el.children){      const inputElement = document.createElement('input')      inputElement.setAttribute(\"type\", \"checkbox\")      liElement.append(inputElement)      const spanElement = document.createElement('span')      spanElement.textContent = el.name      liElement.append(spanElement)      const ulElement = document.createElement('ul')      liElement.append(ulElement)      createTreeView(el.children, ulElement)    }     else if(!el.children){        liElement.textContent = el.name      }  })}createTreeView(menu, root);",
        "url": "//%EC%9D%B4%EC%9C%A0%EC%A0%95/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/19/reading(2)-YJ.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-19-ec-98-a4-ea-b0-9c-ec-95-88-eb-a7-906-html": {
        "title": "윤태연 독서일지: 오개안말(6)",
        "tags": "윤태연",
        "date": "October 19, 2022",
        "author": "",
        "category": "",
        "content": "협업을 돕는 화면 설계서: 2022 / 10 / 19Part2. 기획자의 일3. 협업을 돕는 화면 설계서협업에 뭐가 중요한지 알았다. 본격적으로 기획자에게 정말 중요한 화면 설계서가 협업에 중요한 이유, 쓰는 방법 등에 대해 고찰해보자!  설계서를 작성하는 이유: 설계서 중심으로 모든 협업이 가능하게          개발 요청서 뿐만 아니라 이슈가 생길 시의 상황도 담겨져 있어야 설계서 중심 협업이 가능, 히스토리 등을 정리하여 설계서 중심으로 소통이 가능하게        목적을 명확하게 전달: 설계서 작성 중 기획의 의도가 제대로 전달돼야함, 그래야 구체적인 방안을 같이 모색하는 등 수월한 협업 가능  설계서 타이틀: 리뷰 회의 이전 다른 포지션이 설계서를 안봤을 확률도 높고, 빠른 소통을 위해 타이틀을 함축적이지만 자세하게 작성          제목만 있으면 방향이 뒤틀릴 수도 그래서 추가해야함: 1. 작성 날짜 2. 플랫폼 3. 기능 상세 명칭 및 기획방향(신규/개션 등) 4. 문서 버전      문서제목: 상품 검색 기획 설계서 =&gt; 문서제목(신규): 2022/10/31_A몰_상품 검색 신규 기획 설계서_v1.0 ~~ 문서제목(고도화): 2022/10/31_A몰_상품 검색 고도화 기획(고급 옵션) 설계서_v1.0        설계서 속 스토리텔링: 설계서에서 탄탄하게 구성되면 설득력 업          타이틀(기능 소개), 목차, 버전 이력 관리(히스토리 공유), 설계목적 및 기대효과(기획배경 및 목적 공유), 정책 및 프로세스 정의(범위 공유), UI 설계 방향        리뷰 요청 방법: 리뷰 회의 전 회의 참석자들에게 공유하는데 지키면 좋을 예의들, 기획 의도를 제대로 전달 위함          ‘설계서 작성하는데 미리 고려해야할 부분이 있을까요?’ 같은 말로 미리 언질      그 후 리뷰 회의 건 설계서 발송하는 데 있어 간 회의 일정 및 기획 배경, 세부 내용 등을 메일 내용에 포함시켜 발송하기      이런 식으로 설계서를 작성하면 협업에 한층 수월해질 것이다. 부탁의 자세를 가지되 자신을 낮추는 것만이 아닌 자신의 과정을 공유하는 것만으로도 도움이 될 것이다.",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/19/%EC%98%A4%EA%B0%9C%EC%95%88%EB%A7%906.html"
      }
      ,
    
      "ec-9d-b4-ed-9d-ac-ec-a7-84-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-18-reading-hj-html": {
        "title": "이희진 독서일지(1): 한 권으로 읽는 컴퓨터 구조와 프로그래밍",
        "tags": "",
        "date": "October 18, 2022",
        "author": "",
        "category": "",
        "content": "221001(1일차) 34p ~ 49p프로그래밍 언어는 결국 사람이 만들었기 때문에 불완전성(버그)이 존재한다. 이에 대처하기 위함도 있으나 기본적으로 좋은 프로그래밍은 컴퓨터에게 효율적이고 정확하게 명령하는 것이므로 컴퓨터를 이해하는 건 좋은 기반이 된다. 하지만 메모리 관리가 필수였던 C 언어와 달리 메모리 걱정을 하지 않아도 된 자바를 비롯해 비슷한 언어들이 대거 등장하게 된 것은 분명한 발전이나 컴퓨터에 대한 이해를 불필요하게 여겨 프로그래머의 역량을 낮추는 계기가 되었으므로 이에 대한 역량 향상은 필수적이다.221003(2일차) 51p ~ 57p컴퓨터 언어는 자연어(인간의 언어)와 유사하다. 둘은 기호(문자)가 들어갈 상자, 상자에 들어갈 기호, 상자의 순서로 나눌 수 있는데 컴퓨터 언어에서 이 상자를 비트(2진법 사용을 뜻하는 binary와 숫자를 뜻하는 digit의 합성어)라고 칭한다. 비트 사용법 중 하나로 논리 연산이 있는데 대표적인 게 불리언 대수로, 기본적인 연산자로 NOT, AND, OR, XOR(첫 번째 비트와 두 번째 비트가 서로 다른 값이어야 참)이 있다. 드모르간 법칙(! false === true)을 바탕으로 AND 연산자로 OR을 나타낼 수 있으나 연산자의 사용은 적을수록 효율적이다.221004(3일차) 58p ~ 67p비트는 2진수로 숫자를 표현할 수 있다. 2의 거듭제곱 단위로 나눈 상자에 나누어 0과 1을 담아 숫자를 표현하며 이때 0과 1의 개수에 따라 비트의 수가 결정된다(e.g. 5,028는 13비트). 가장 오른쪽의(수를 가장 작게 변화시키는 유효) 비트를 LSB, 가장 왼쪽의(가장 크게 변화시키는 유효) 비트를 MSB라 한다. 2진수 또한 덧셈과 뺄셈이 가능하며 비트로 음수를 표현할 땐 ‘2의 보수’를 사용한다. 이때 ‘2의 보수’란 양수 2진수에 NOT 연산자를 추가한(0과 1을 반대로 한) 후 1을 더하는 방식을 뜻한다(e.g. 1 = 001 / -1 = 111).221006(4일차) 68p ~ 73p앞서 말한 숫자 표현은 정수에 한정됐으나 비트로 실수 표현 또한 가능하다. 고정소수점(2의 거듭제곱을 분모로 하는 분수들을 이용해 2진법으로 소수 표현), 부동소수점 표현법 등 다양하게 있으나 해당 방법들의 비효율성(비트의 낭비)을 해결하기 위해 등장한 것이 ‘IEEE 부동소수점 수 표준’이다. 0.0012를 1.2(가수) x 10(밑)⁻³(지수)로 표현하는 것처럼 밑 2의 지수만 변경해 표현하는 부동소수점에 트릭을 사용해 정밀도를 높인 버전(1. 정규화(가수를 조정해 맨 앞에 0이 없게 만듦), 2. 맨 왼쪽 비트의 1을 생략함)으로 기본 정밀도 부동소수점과 2배 정밀도 부동소수점이 자주 쓰인다.221007(5일차) 74p ~ 78p2진수의 조작에 있어 불편함을 최소화시키기 위해 사람들은 다양한 표현법을 강구했다. 8진 표현법과 16진 표현법이 그것인데 각각 2진수 비트들을 3개씩, 4개씩 묶어 표현한다. 즉, 11010011111111000001 같은 엄청난 숫자를 4개씩 묶어 (1101/0011/1111/1100/0001) 표현하고 이를 각 진수 표현법의 규칙에 맞춰 변환하면 10몇개의 숫자들이 한 자릿수의 숫자 및 문자로 정리가 된다(예: 1101/0011/1111/1100/0001 =&gt; d3fc1). 그렇다면 이런 다양한 표기법을 컴퓨터는 어떻게 구분할까. 구분할 수 있다. 0부터 시작하면 8진수, 1~9 사이의 숫자로 시작하면 10진수, 0x가 앞에 붙으면 16진수다. 이러한 진수 표현에 있어 절대 빠질 수 없는 비트들은 너무 작기 때문에 효율적인 표현을 위해 일정 개수(4, 8, 16 등)로 묶은 덩어리에 이름을 붙여 표현한다(니블, 바이트, 하프워드 등).221012(6일차) 79p ~ 89p비트로 수를 표현할 수 있다. 그리고 이 수로 문자를 표현할 수 있다. 아스키 코드는 그 방법 중 하나로 키보드 위 모든 기호에 대해 7비트 수 값을 할당했다. (예: 65는 대문자 A를 뜻함) 키보드 위 문자 외에도 아스키 코드로 아스키 제어 문자 또한 나타낼 수 있다(예: 텍스트 시작, null 등). 또한 영어만 지원했던 기존과 달리 다양한 언어의 표준(유니코드)도 도입하여 문자에 16비트 코드를 부여한다. 하지만 아무리 비트가 저렴해졌다고 해도(이 때문에 기존 7비트에서 16비트까지 증가) 문자 표현에 있어서 8비트면 충분하기 때문에 ‘유니코드 변환 형식 8비트(UTF-8)’를 아스키가 아닌 문자에 대한 주된 인코딩(다른 비트 패턴 표현을 위해 사용한 비트 패턴) 방법으로 사용할 수 있다. 인코딩의 방식은 다양하고 그 예로 QP(쿼티드 프린터블)인코딩, 베이스64 인코딩, URL 인코딩이 있으며 해당 인코딩들은 기본적으로 문자 8비트 데이터를 송수신 가능한 비트로 쪼개어 인코딩한다. 마지막으로, 수로 색 또한 표현할 수 있다. 컴퓨터는 가산 색 시스템을 바탕으로 한 RGB 모델을 통해 색을 표현한다. RGB은 적, 녹, 청 각각의 진함 정도를 숫자로 표현하며 해당 색에는 각각 8비트가 할당된다. 하지만 여기서 미사용되는 8비트가 존재하는데 이는 색의 투명도를 담당하는 부분이다. 또한 이러한 색은 16진 트리플렛(예: #ffff00은 노란색)을 이용해 각각의 8비트 값을 16진 표기를 통해 두 자리 문자로 바꿔서도 표현할 수 있다. 221015(7일차) 91p ~ 97p비트는 매우 중요하나, 톱니바퀴로 돌아가던 계산기의 시초에 비트는 존재하지 않았고 계산자를 이용한 오트레드의 기계식 계산기와 찰스 배비지의 차분 기관에도 비트의 개념은 존재하지 않는다. 컴퓨터가 언제부터 비트와 함께 했는지 알아 보기 전, 먼저 아날로그(예: 손가락)와 디지털(예: 자)에 대해 알아야 한다. 우리는 자로 실수를 표현할 수 있으나 손가락으로는 할 수 없다. 자는 수학적으로 연속적이나 손가락은 이산적(하나하나 다른 존재로 구분됨)이기 때문이다. 전자기술 영역에서 아날로그는 연속적인 것을, 디지털은 이산적인 것을 뜻하는데 실수를 계산할 수 있단 측면에서 아날로그가 계산에 있어 적합해 보이나 큰 숫자를 표현하기 위해 그만큼 커다란 자가 필요하고 이는 에너지의 효율을 위해 작은 하드웨어를 추구하는 흐름에 어긋난다. 뿐만 아니라 우리가 연속성을 이용해 계산을 하면 외부의 그 어떤 방해도 없어야만 정밀도 높은 측정이 가능한데 회로 내에서 이러한 누화 효과를 막는 건 실질적으로 불가능하므로 높은 정밀도를 추구해야 한다면 잡음 내성을 가진 디지털 회로는 필수적인 존재다.      221016(8일차) 98p ~ 108p정밀도를 위해 많은 엔지니어들은 하단부, 직선부, 상단부가 나누어져 출력의 단계가 구분된 전이 함수를 이용해 아날로그로부터 디지털을 구현하고자 했다.앞서 출력값이 급변하는 지점(판정 기준)을 문턱값이라 한다. 이러한 문턱값이 비트에 적용될 경우, 0과 1만이 존재하는 만큼 출력값의 변화폭이 크기 때문에 전이 함수의 하단부(차단)와 상단부(포화) 간의 간격이 더욱 넓어져 그만큼의 재량권이 증가한다. 컴퓨터에 대해 이해하기 위해선 원동력이라 할 수 있는 전기 이야기를 안 할 수가 없다. 전기를 흐르게 하거나 차단하는 게이트 밸브의 열고 닫힘은 곧 1과 0과 같으며 이를 이용해 논리 연산자의 구현이 가능해진다. 전기는 물과 같기 때문에 흐름에 있어 전파 지연이 발생할 수 있고 전류는 전압과 저항에 영향을 받는다(옴의 법칙: 전류는 전압을 저항으로 나눈 값과 같음, I = V/R). 이러한 전기는 부도체를 이용해 만든 스위치를 통해 제어할 수 있으며 전기의 흐름을 발생 또는 통제하는 전체적인 시스템을 회로라고 하며 이는 스키매틱(회로도)을 통해 문서화된다. 스위치가 단극인지 쌍극인지에 따라 통제할 수 있는 회로의 수가 다르며 만약 스위치 하나로 켜고 끄는 걸 동시에 하는 게 아닌 스위치마다 다른 기능(켜고 끔)을 부여하고 싶다면 단극쌍투 스위치를 이용하면 된다.221018(9일차) 109p ~ 115p전자적 기술은 역사를 거쳐 발전했고 단순함에서 복잡함으로 나아갔고 그 첫 번째 역사로는 릴레이가 있다. 선을 말아 코일로 만들고 전류를 흐르게 하면 해당 코일은 전자석이 되며, 릴레이는 이러한 전자석을 통해 회로의 스위치를 움직인다. 하지만 릴레이는 속도가 느리고 사이에 이물질이 있으면 성능이 급격하게 저하되기 때문에 이를 위한 대체재로 물체를 충분히 가열하면 전자가 튀어나오는 열전자 방출을 원리로 하는 진공관을 만들었고 뒤이어 진공관과 비슷하지만 반도체(도체와 반도체 사이를 오가는 물질)로 이뤄진 기판 또는 슬랩 위에 만들어지는 트렌지스터가 만들어졌으며 해당 방식이 가장 우세하게 쓰이고 있으며 추후 발명한 직접 회로를 통해 트렌지스터에 복잡한 시스템을 구현하는 것을 더욱 적은 부품으로 만드는 게 가능해졌다. 이렇듯 사람들은 더 작고 더 저렴하고 에너지를 효율적으로 사용할 수 있도록 회로를 만드는 기술 개발에 힘을 썼다. 221022(10일차) 116p ~ 122p논리 연산을 수행하는 회로를 논리 게이트(게이트)라 한다. 게이트 IC(집적 회로)를 사용하면 회로를 처음부터 설계하지 않고 복잡한 회로 구현이 가능하며 게이트의 종류로는 AND, OR, XOR, 인버터(NOT)가 있다. 하지만 AND 게이트나 OR 게이트는 NAND(not and)와 NOR(not or)에 트렌지스터를 붙여 출력을 반전시키는 방식으로 구성되어 효율 측면에서 좋지 않기 때문에 디지털 회로 설계에 기본적으로 사용하는 게이트는 NAND와 NOR이다. 드모르간 법칙에 의해 NAND 게이트만으로 AND을 나타낼 수 있으나 반대의 경우는 장치가 필요하므로 NAND(더불어 NOR)을 기본적으로 썼을 때 더 많은 논리 표현이 가능하다. 이런 게이트는 논리 신호(0 또는 1)를 받아 처리하나 앞서 설명했던 디지털적 장치를 이용한다 해도 신호의 속도가 느릴 경우 잡음이 발생해 출력 신호에 글리치(작은 오류)가 발생한다. 이는 판정 기준이 이력(과거 현상)에 따라 달라지는 이력 현상을 통해 해결할 수 있는데 즉, 0에서 1이 될 때와 1에서 0이 될 때에 다른 문턱값을 매기면 값이 변동 간격이 기존에 비해 크게 변하고 잡음 내성 또한 강해진다. 이러한 원리를 사용하는 게이트로 슈미트 트리거가 있다. 하지만 이력만으로도 충분하지 못할 경우가 있는데 이때는 차동(차이, 격차) 신호를 이용한다. 이력은 문턱값이라는 절대 기준에 평가되었으나 차동 신호는 서로 반전관계에 있는 신호 쌍 간의 차이로 측정하기 때문에 잡음의 영향을 덜 받는다. 물론 차등 신호 역시 압도적인 잡음에는 영향을 받게 되는데 이때는 공통 모드 판별비(CMRR)를 이용해 처리 가능한 잡음의 양을 미리 표시한다. 뿐만 아니라 회로 설계자들은 전파 지연도 가정하며 게이트의 효율적 작동을 고민해야 한다. 221023(11일차) 123p ~ 134p게이트의 출력에는 다양한 유형이 존재한다. 일반적 게이트 출력은 토템폴이라 하는데 이는 나란히 붙은 (1과 0을 담당는)트렌지스터 모양이 원기둥 토템과 닮아 붙여진 이름으로 출력의 1을 얻기 위해 출력과 높은 논릿값 1을 연결하는 것을 액티브 풀업이라 말하며 토템폴 출력을 서로 연결하면 음극과 양극을 서로 연결하는 모양이 되어 불가능하다. 오픈 컬렉터/오픈 드레인 출력은 액티브 풀업이 없기 때문에 서로 연결이 가능하며 필요하면 패시브 풀업(풀업 저항을 논리적인 1값을 공급하는 공급 전압에 연결)에 연결할 수 있다. 하지만 해당 방식은 액티브 풀업만큼 응답이 빠르지 않아 이를 해결하기 위한 트라이스테이트 출력이 있다. 기존의 두 가지 상태에서 꺼진 상태(hi-Z(임피던스))인 세 번째 상태를 더해 함께 다루는 방식으로 이로 인해 활성화 입력이 존재한다. 해당 출력을 사용하면 수많은 장치를 서로 선으로 직접 연결할 수 있으나 한 번에 한 개의 장치만 활성화해야 한다. 게이트의 등장으로 하드웨어 설계 과정은 단순해졌고 다양한 게이트 조합이 등장했는데 가산기, 디코더, 디멀티플렉서, 실렉터가 그것이다. 가산기는 비트의 덧셈에서 작동되는 논리 연산에서 착안해 XOR 게이트와 AND 게이트를 조합해 만들 수 있으며 디코더는 인코딩된 수를 개별 비트의 집합으로 만드는 기능을 논리 게이트로 구현한 것이다. 이를 이용해 디멀티플렉서(디먹스)를 만들 수 있는데 입력을 몇 가지 출력 중 한 곳에 전달할 수 있다. 마지막 실렉터(또는 멀티플렉서(먹스))는 마찬가지로 디코더에 게이트를 추가해 구현하며 해당 스키매틱을 보면 디먹스를 뒤집은 모양이다. ",
        "url": "//%EC%9D%B4%ED%9D%AC%EC%A7%84/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/18/reading-HJ.html"
      }
      ,
    
      "ec-a0-84-ec-98-88-eb-a6-b0-eb-b3-b5-ec-8a-b5-ec-9d-bc-ec-a7-80-2022-10-17-reapeating-2-yr-html": {
        "title": "전예린 복습일지(2)",
        "tags": "",
        "date": "October 17, 2022",
        "author": "",
        "category": "",
        "content": "221017 || side Effect(부수 효과)와 useEffect함수 내의 어떤 구현이 함수 외부에 영향을 끼치는 경우 해당 함수는 Side Effect가 있다고 이야기한다. 보통 React 애플리케이션을 작성할 때 AJAX 요청, LocalStorage 또는 타이머와 같이 React와 상관없는 API를 사용하며 많은 Side Effect가 발생하게 된다.React는 이러한 Side Effect를 다루기 위한 Hook인 Effect Hook useEffect함수를 제공한다.useEffect() 함수는 React component가 렌더링 될 때마다 특정 작업(Side effect)을 실행할 수 있도록 하는 리액트 Hook이다. useEffect의 기본형태를 살펴보자.useEffect(function, deps)function은 실행하고자 하는 함수이며, 해당 함수 내에서 side Effect를 실행하면 된다. deps는 배열 형태이며 function을 실행시킬 조건이다. deps 배열 내의 어떤 값이 변할 때에만, function이 실행된다.이제 useEffect의 조건부 실행에 대해 알아보자.  useEffect(function,[])  useEffect(funtion)  useEffect(function,[name])1번처럼 deps 부분에 빈 배열을 넣게되면, 맨 처음 렌더링 될 때 한 번만 실행된다. 2번처럼 deps 부분을 생략한다면, 해당 컴포넌트가 렌더링 될 때마다 useEffect가 실행된다.3번처럼 deps 부분에 특정 값을 넣게되면, 그 특정 값인 ‘name’이 업데이트 될 때마다 실행된다.",
        "url": "//%EC%A0%84%EC%98%88%EB%A6%B0/%EB%B3%B5%EC%8A%B5%EC%9D%BC%EC%A7%80/2022/10/17/reapeating(2)-YR.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-17-repeating-lift-state-html": {
        "title": "윤태연 복습일지(2)",
        "tags": "윤태연",
        "date": "October 17, 2022",
        "author": "",
        "category": "",
        "content": "상태 끌어올리기: 2022 / 10 / 17리액트의 특징과 상태 끌어올리기의 배경우리는 리액트식 사고를 배웠다. 바로 기능마다 사용자 정의 컴포넌트를 만들어 파일, 페이지, 기능 등을 나눠 제작했다. 그리고 리액트는 아래서부터 차근차근 작은 컴포넌트를 조합해 큰 컴포넌트를 만들어 낸다. 이런 식으로 만들어 리액트는 ‘상향식 구조’(트리 구조)로 개발된다.또 리액트 특징이 데이터의 흐름은 위에서 아래로 흐른다. 왜냐면 &lt;Twittler&gt; 안에서 &lt;Tweets&gt;가 렌더링 되는 식의 트리 구조로 이뤄져 있어 부모에서 자식이 이어지는 형태를 지니고 있고, 유지•보수에 용이하기에 하향식이다. 또 비슷한 이유로 데이터의 흐름은 단방향이다. 왜냐고 묻지 말자. Virtual DOM과 관련이 있기에 그때 이 기억을 상기하여 그때 제대로 배우면 된다. 한마디로 Virtual DOM 특성 상 뷰를 통채로 바꾸기에 훨씬 안정적이고 관리 측면에서 우수하다.그런데 자식이 부모의 상태를 바꿀 때가 있다?! 예를 들어 하나의 SNS을 담는 컴포넌트가 있고, 크게 2개로 게시물과 입력창의 컴포넌트가 있다고 가정해보자, 또한 게시물의 기본값이(State) 부모에 있다고 하자. 입력(Input)을 하면 전체 SNS 게시물 목록에 영향을 줘야하는 로직을 짜야한다. 엥? 역방향, 자식이 부모의 상태의 기본값에 영향을 줬네?! 이거 안돼요! 라고 말할 수 밖에 없다. 하지만 여기서 우리는 Props와 파라미터, 또 setState를 한방에 묶는 엄청난 스킬 ‘상태 끌올’을 사용할 수 있다.상태 끌어올리기 사용법한마디로 해서 자식의 사용자 정의 컴포넌트(함수)에 파라미터를 넣고 함수를 정의하는 중괄호 안에다가 ⭐️”전달하려는 값”을 파라미터(값)으로 넣어주고, 부모에 자식을 렌더링하는 곳에 Props를 설정하고 그 Props에 적용하고픈 부모의 함수를 중괄호 안에 넣어주면 된다. 예시를 보며 읽으며 어떻게 적용되는지 보자.이렇게 Props를 이용하여 리액트의 규칙을 거스르지 않고도 자식의 반항을 적용할 수 있다. 화이팅!",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/17/Repeating-Lift-State.html"
      }
      ,
    
      "ea-b9-80-ec-9d-bc-ed-83-9c-eb-b3-b5-ec-8a-b5-ec-9d-bc-ec-a7-80-2022-10-17-review-it-html": {
        "title": "김일태 복습일지",
        "tags": "김일태",
        "date": "October 17, 2022",
        "author": "",
        "category": "",
        "content": "JSON인터넷으로 데이터를 주고받을 때 깔끔한 형식으로 정리한 데이터를 주고 받아야한다.이를 위해 고안된 데이터 담는 형식 중 하나이며 지금 가장 주류라고 생각하면 된다.XML&lt;데이터이름&gt;값&lt;/데이터이름&gt;// EX&lt;삼성전자&gt;50000&lt;/삼성전자&gt;&lt;카카오&gt;100000&lt;/카카오&gt;&lt;food&gt;  &lt;name&gt;Belgian Waffles&lt;/name&gt;  &lt;price&gt;$5.95&lt;/price&gt;  &lt;description&gt; Belgian Waffles &lt;/description&gt;  &lt;calories&gt;650&lt;/calories&gt;&lt;/food&gt;JavaScript 쓰면 object 자료로 쉽게 변환이 가능하지만 작성하기 귀찮고 용량도 많이 잡아먹는다.CSVYear, Brand, Model1997, Ford, E3502000, Mercury, Cougar표 형태를 이루고 있어 데이터베이스에 있던 내용을 CSV로 변환하기 쉽지만, 고차원 데이터는 표현이 어렵다.JSON(JavaScript Object Notation){\"name\" : \"kim\", \"age\" : 20}객체와 비슷한 형식을 가져 고차원 데이터도 표현이 가능하다.객체와 다른 점은 데이터마다 키값을 설정해야 하며 ““로 감싸야 한다.(키 값이 문자 취급)JSON.stringify() // object나 array를 JSON 형식으로 변환JSON.parse() // JSON 형식을 다시 object나 array로 변환재귀함수자기 자신을 반환하는 함수를 의미하며 주어진 문제를 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우나 중첩된 반복문이 많아 엄청나게 긴 for문을 간결하게 줄일 수 있고 반복문의 중첩 횟수(number of loops)를 예측하기 어려운 경우도 간단하게 해결할 수 있다.",
        "url": "//%EA%B9%80%EC%9D%BC%ED%83%9C/%EB%B3%B5%EC%8A%B5%EC%9D%BC%EC%A7%80/2022/10/17/Review-IT.html"
      }
      ,
    
      "ea-b9-80-ec-9d-bc-ed-83-9c-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-17-clean-code-reading-it-html": {
        "title": "김일태 독서일지 : Clean Code",
        "tags": "김일태",
        "date": "October 17, 2022",
        "author": "",
        "category": "",
        "content": "1. 깨끗한 코드코드는 요구사항을 상세히 표현하는 수단중복을 피하라. 한 기능만 수행하라. 제대로 표현하라. 작게 추상화하라보이스카우트 규칙 (캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라2. 의미 있는 이름프로그래밍은 사회 활동이기 때문에 발음하기 쉬운 이름이 중요하다메서드 이름은 독자적이고 일관적이어야 한다암기는 요즘 나오는 도구에게 맡기고, 우리는 문장이나 문단처럼 읽히는 코드를 짜는 데 집중하자3. 함수함수를 만드는 첫째 규칙은 ‘작게!’다. 그 다음은 ‘더 작게!’다함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야한다. 그 한 가지만을 해야 한다함수는 그 언어에서 동사며, 클래스는 명사다",
        "url": "//%EA%B9%80%EC%9D%BC%ED%83%9C/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/17/Clean-Code-Reading-IT.html"
      }
      ,
    
      "ec-9d-b4-ec-98-81-ec-9a-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-16-reading-3-yw-html": {
        "title": "이영우 독서일지(3)",
        "tags": "",
        "date": "October 16, 2022",
        "author": "",
        "category": "",
        "content": "4일차 28p ~ 34p 이름은 어디에서나 쓰이기 때문에 잘 짓는것이 중요하다.에 대한 추가내용.",
        "url": "//%EC%9D%B4%EC%98%81%EC%9A%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/16/reading(3)-YW.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-16-ec-98-a4-ea-b0-9c-ec-95-88-eb-a7-905-html": {
        "title": "윤태연 독서일지: 오개안말(5)",
        "tags": "윤태연",
        "date": "October 16, 2022",
        "author": "",
        "category": "",
        "content": "2-2. 협업을 위한 사전 준비: 2022 / 10 / 16Part2. 기획자의 일2. 협업을 위한 사전 준비기획자로서 가져야하는 협업의 자세를 보자. 전에는 기획자는 화면 그리기나 기능 구현이 아닌 방향성 설정과 유지를 보는 포지션이라고 배웠다. 그러므로 이번 목차엔 전체적인 틀을 짜는 기술을 서술했다. 서비스 전체 구조를 보는 IA를 웹사이트 구조에 기반해 구조화해 방향성을 구체적으로 설정한다. 근데 또 IA를 그리기위해 기능들을 구체적으로 리스트업해야하는데 MECE와 하이라키 기법이 있다.  MECE: 맥킨지에서 개발한 기법, 목록화된 기능들을 유사한 성질끼리 묶어주는 역할을 함, 거창하게 기법어쩌구 했지만 경험적으로 체득한 사람도 많음  하이라키: 부모-자식 관계 등 상하 위계 구조를 의미, 디자인(UI/UX)에서 많이 쓰이는 계층 구조화의 일환으로 IA에 Depth(Level)로 같이 기획한다.구현해야할 기능들을 일단 관찰하고 MECE로 비슷한 기능들을 모아 카테고리화하고 하이라키로 구현 중요도부터 기능들을 매겨 Depth로 나타낸다.이렇게 기준을 나눠 유사한 기능을 모아둠과 동시에 세부적인 기능을 기획에 맞춰 IA를 짜서 방향성을 맞춘다.",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/16/%EC%98%A4%EA%B0%9C%EC%95%88%EB%A7%905.html"
      }
      ,
    
      "ea-b0-95-ec-a7-84-ec-9b-90-eb-b3-b5-ec-8a-b5-ec-9d-bc-ec-a7-80-2022-10-16-repeating-jw-copy-html": {
        "title": "강진원 복습일지2",
        "tags": "강진원",
        "date": "October 16, 2022",
        "author": "",
        "category": "",
        "content": "AJAXJavaScript, DOM, Fetch, XMLHttpRequest, HTML 등의 다양한 기술을 사용하는 웹 개발 기법AJAX (Asynchronous JavaScript And XMLHttpRequest)란 비동기 자바스크립트와 XML을 말한다. 서버와 통신하기 위해 XMLHttpRequest(https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest) 객체를 사용하는 것을 말하며, 서버와 비동기적으로 데이터를 주고받는 자바스크립트 기술을 의미한다.AJAX의 강력한 특징은 페이지 전체를 refresh 하지 않고서도 수행 되는 “비 동기성”이다.쉽게 말해서 클라이언트가 서버로부터 GET요청을 하고 응답을 받을 때, 새로 고침 없이 수행 될 수 있게 해준다.AJAX의 주요 두가지 특징  페이지 새로고침 없이 서버에 요청  서버로부터 데이터를 받고 작업을 수행AJAX의 두가지 핵심 기술  JavaScript와 DOM  Fetch  Fetch라는 내장 함수를 사용하면, 페이지를 이동하지 않아도 서버로부터 필요한 데이터를 받아 올 수 있다. Fetch는 사용자가 현재 페이지에서 작업을 하는 동안 서버와 통신할 수 있도록 한다.즉, 브라우저는 Fetch가 서버에 요청을 보내고 응답을 받을 때까지 모든 동작을 멈추는 것이 아니라 계속해서 페이지를 사용할 수 있게 하는 비동기적인 방식을 사용한다.Fetch를 통해 전체 페이지가 아닌 필요한 데이터만 가져와 DOM에 적용 시켜 새로운 페이지로 이동하지 않고 기존 페이지에서 필요한 부분만 변경할 수 있다.AJAX의 장점  서버에서 HTML을 완성하여 보내주지 않아도 웹페이지를 만들 수 있다.  표준화된 방법 (XHR이 표준화 되면서부터 브라우저에 상관없이 AJAX를 사용할 수 있게 되었다.  유저 중심 애플리케이션 개발  더 작은 대역폭(대역폭 : 네트워크 통신 한 번에 보낼 수 있는 데이터의 크기)    AJAX의 단점    Search Engine Optimization(SEO)에 불리 (AJAX 방식의 웹 애플리케이션의 HTML파일은 뼈대만 있고, 데이터는 없기 때문에 사이트 정보를 긁어가기 어렵다. =&gt; 서버로부터 비동기적으로 필요한 데이터를 가져 오기때문에 처음 받는 HTML 파일에는 데이터를 채우기 위한 틀만 작성되어 있는 경우가 많음)  뒤로가기 버튼 문제 (AJAX에서는 이전 상태를 기억하지 않는다)2022-10-24 MONJSONJSON(Javascript Object Notation)은 데이터 교환을 위해 만들어진 객체 형태의 포맷이다.조금 더 풀어서 말하면 JavaScript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반(string)기반의 표준 포멧이다.네트워크를 통해 어떤 객체 내용을 다른 프로그램에 전송한다고 가정할 때(서버-&gt;클라이언트 또는 반대의 경우) 메세지 객체가 전송 가능하려면 메세지를 보내는 발신자와 메시지를 받는 수신자가 같은 프로그램을 사용하거나, 문자열 처럼 범용적으로 읽을 수 있는 형태여야 한다.그러나 모두가 같은 프로그램을 사용한다는 보장이 없으니 어떤 환경에서든 읽고 쓸 수 있도록 JSON 형태로 변환을 해서 데이터를 주고 받아야 한다는 뜻이다.전송 가능한 조건 (transferable condition)  수신자(reciever)와 발신자(sender)가 같은 프로그램을 사용한다.  또는, 문자열처럼 범용적으로 읽을 수 있어야 한다.이를 위한 메서드는 다음과 같다.  JSON.stringify : 객체를 JSON으로 변환합니다. (직렬화 serialize)  JSON.parse : JSON을 객체로 변환합니다. (역직렬화 deserialize)JSON으로 변환된 객체의 타입은 문자열이다. 발신자는 객체를 직렬화한 문자열을 누군가에게 객체의 내용을 보낼 수 있다. 그러고 나면 수신자는 이문자열을 다시 역직렬화 하여 직렬화된 문자를 객체의 형태 그대로 다시 받을 수 있게 된다.이처럼, JSON은 서로 다른 프로그램 사이에서 데이터를 교환하기 위한 포맷이다. 그리고 JSON 포맷은 자바스크립트를 포함한 많은 언어에서 범용적으로 사용하는 유명한 포맷이다.JSON의 기본 규칙JSON은 얼핏 보기에 자바스크립트의 객체와 별반 다를 바가 없어 보이지만, 자바스크립트의 객체와는 미묘하게 다른 규칙이 있다.                   자바스크립트 객체      JSON                  키      키는 따옴표 없이 쓸 수 있음{ key : “property” }      반드시 쌍따옴표를 붙여야 함’{“key”:”property”}’              문자열 값      작은따옴표도 사용 가능{ “key” : ‘property’ }      반드시 큰따옴표로 감싸야 함’{“key”:”property”}’              키와 값 사이 공백      사용 가능{“key” : ‘property’}      사용 불가능’{“key”:”property”}’              키-값 쌍 사이 공백      사용 가능{ “key”:’property’, num:1 }      사용 불가능’{“key”:”property”,”num”:1}’      ",
        "url": "//%EA%B0%95%EC%A7%84%EC%9B%90/%EB%B3%B5%EC%8A%B5%EC%9D%BC%EC%A7%80/2022/10/16/Repeating-JW-copy.html"
      }
      ,
    
      "ec-9d-b4-ec-98-81-ec-9a-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-15-reading-2-yw-html": {
        "title": "이영우 독서일지(2)",
        "tags": "",
        "date": "October 15, 2022",
        "author": "",
        "category": "",
        "content": "3일차 22p ~ 28p이름은 어디에서나 쓰이기 때문에 잘 짓는것이 중요하다.이름을 잘 짓는 방법을 소개한다.  의도를 분명하게 밝혀라.  그릇된 정보를 피해라.  의미 있게 구분해라.  발음하기 쉬운 이름을 사용해라.  검색하기 쉬운 이름을 사용해라.",
        "url": "//%EC%9D%B4%EC%98%81%EC%9A%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/15/reading(2)-YW.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-15-ec-98-a4-ea-b0-9c-ec-95-88-eb-a7-904-html": {
        "title": "윤태연 독서일지: 오개안말(4)",
        "tags": "윤태연",
        "date": "October 15, 2022",
        "author": "",
        "category": "",
        "content": "2-1. 협업을 위한 준비물: 2022 / 10 / 15Part2. 기획자의 일1. 서비스 기획 들여다보기파트1은 개발자 얘기였고, 이제 기획자를 보도록 하자. 2-1은 기획의 정의와 범위, 유형, 실제 기획 개발 과정 등을 얘기한다.  범위: 기업마다 환경, 규모 등 다르기에 딱 잘라 정의하기 애매          사전적인 의미로 정의: 서비스 방향성에 따른 목적, 기준을 정하고 그거에 맞춰 실행 설계 및 제안                  ‘대상에 따른 변화에 맞는 목적 확인’: 시장 분석, 예비 고객 타겟팅          ‘목적 성취를 위한 적합한 행동 찾기’: 목적에 맞춰 핵심 니즈에 방향성을 둠(스케치)          ‘설계하기’: 스케치를 실제로 구현하기 위한 설계서 작성                      유형: 서비스 유형에 나뉨, 장단점이 다르기에 커리어를 어떻게 쌓을지 고민          인하우스(자체 서비스 운영 기획): 주로 서비스 성장을 위해 고객 데이터를 보며 분석하고 기획하는 걸 반복, 직무 수행하며 더더욱 폭이 좁아지는 경향이 있어 다양한 경험 X      에이전시(외주, SI): 제안요청서(RFP)에 따라 세부 기획하고 처음과 끝까지 기획해 빠르게 성장하고 다양한 경험, 양질의 레퍼런스를 얻을 수 있음, 데드라인이 정해져 있어 시간에 쫓기고, 야근이 잦음        기획 프로세스: 사소한 아이디어가 떠오른 뒤 해야할          리서치/분석: 시장에서 경쟁력? 가치 유무? 시장규모, 경쟁업체 등      방향성 설정: 서비스 주요 타깃을 정해 얻는 효용, 행동을 예측하기, 가설 세우기      컨셉 도출: PoC(Product of Concept)를 짜서 가설을 이미지화 하기      설계/기획: IA, 와이어프레임을 짜 서비스 구조 구축, 개발자와 협업 시작      디자인/개발: 정한 방향성을 유지하며 예쁨-기능(디자인-개발)의 균형을 맞추는 게 중요!        결론: 방향성이 제일 중요, 방향성에 맞는 서비스와 그 기준을 세워 디자이너, 개발자 등 모두를 충족시킬 수 있게 조정하는 것이 기획자의 일, 또 기획안의 프로토타입을 만들어 시각화해 구체화하는 것도 중요, 방향성의 구체화와 사용자 관점에서 볼 수 있어 좋음",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/15/%EC%98%A4%EA%B0%9C%EC%95%88%EB%A7%904.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-14-ec-98-a4-ea-b0-9c-ec-95-88-eb-a7-903-html": {
        "title": "윤태연 독서일지: 오개안말(3)",
        "tags": "윤태연",
        "date": "October 14, 2022",
        "author": "",
        "category": "",
        "content": "1-3. 협업을 위한 준비물: 2022 / 10 / 14Part1. 가깝고도 먼 개발자3. 협업을 위한 준비물그렇다면 IT 기업에서의 협업을 위해 어떻게 준비해야할까?      협업에 대한 이유: 즉! 서로 다름을 알고 과정을 공유, 입장을 이해          갈등이 일어나도 같은 목표를 공유한다면 그 목적을 향해 겪는 과정이란 걸 이해한다.      서로 다른 포지션의 업무를 이해하기                  기획자: 업무상 논리적이고 객관적, 그러므로 기획자를 대할 땐 객관적 논거나 근거자료를 제시해 이야기하기          디자이너: 기획된 내용을 바탕으로 EX를 중시하다보니 의도되지않은 디자인이나 1px의 오차나 색상 등 세심한 디테일을 캐치하는 등 자신의 디자인에 민감하다. 이를 알고 상처받지말기.          개발자: 실제 기획을 구현, 문제 해결에 초점을 두다보니 자신의 것 외에 관심이 없을 수도 있고, 직무의 몰입도가 매우 큼                          필요한 개발 지식 습득: 개발자와의 소통은 어려워! 그러니 조금의 이해를 요하자          자주 알려주는 개발자와 친해지기      물어봐 개발 언어 자체보단 회사의 서비스 구조, 개발 프로세스, 자주 쓰는 용어 등을 먼저 파악하기                  개발자도 설명하기 모호한 용어들이 있다. 메모해서 구글링 必                    그렇게 기초를 다져 그제서야 관심이 생긴다면 대중적이고 쉬운 언어부터 학습하기      ",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/14/%EC%98%A4%EA%B0%9C%EC%95%88%EB%A7%903.html"
      }
      ,
    
      "ec-a0-84-ec-98-88-eb-a6-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-12-reading-2-yr-html": {
        "title": "전예린 독서일지(2): 커리어 스킬",
        "tags": "",
        "date": "October 12, 2022",
        "author": "",
        "category": "",
        "content": "22.10.10 월요일 160p~165p일자리를 구하는 방법 || 전통적 구직방법  IT분야 이력서를 전문으로 하는 이력서 작성 전문가를 고용하는 게 가장 좋다.  직장을 구할 때는 매일 몇 개의 일자리에 지원할지 할당량을 정해두는게 좋다.  이력서와 자기소개서는 회사가 공지한 직무 소개나 자신이 찾아낸 해당 회사 관련 정보에 맞추어서 작성하라. 실제 경력 중 직무 소개에 가장 잘 맞는 부분을 강조하고 관련이 없는 부분은 빼거나 축소하라.직무소개에 등장한 단어나 구절을 활용하되 그대로 따라하면 안된다.  직무 소개를 보고 어떤 기술과 특성이 가장 중요한지 판단 후 경력의 순서를 조정하고 더 중요한 부분을 강조하라. 직무 소개에 등장한 표현을 활용하여 자신이 이룬 성취나 업적을 기술하여 입사 후 해당 업무에 잘 적응할 수 있다는 걸 보여줘라.  회사에 대해 조사해라. 그 회사를 조사한 사람만 쓸 수 있는 문구를 넣어라.  이력서를 여러 버전으로 만들어두었다가 각 일자리에 맞게 조금 더 수정해서 제출하라.  구직 활동 현황을 기록하고 결과를 분석해라. 구직 활동을 광고라고 생각하라.  자신이 한 행동에 대한 피드백을 분석해서 원하는 결과가 나올 때까지 계획을 최적화하라.22.10.11 화요일 166p~176p일자리를 구하는 방법 || 고정관념에서 벗어나기  구인 공고를 보고 지원해야만 취업할 수 있다는 생각을 버려라.  인맥을 쌓아라. 많은 사람을 만나고 그들에게 보탬이 되어라.  특정 회사를 겨냥해라.그 회사에 근무하는 지인을 찾아내거나 새로운 인맥을 만들 수도 있고, 그 회사에 보탬이 될 일을 할 수도 있다.  인바운드 마케팅을 활용해라. 인바운드 마케팅이란 다른 이들에게 보탬이 될 일을 해서 자신이 남들을 찾아다니지 않아도 사람들이 자신을 찾아오게 하는 것이다.22.10.12 수요일 177p~181p이력서 || 직접 작성하지 않는 방향  이력서 작성 전문가나 카피라이터가 아닌 이상 이력서를 직접 쓰지마라. 실력 있는 이력서 전문가의 도움을 받아서 만들어라.  주변에 이력서 작성 전문가를 써서 좋은 결과를 낸 사람이 있는지 찾아보라. 소프트웨어 개발자 이력서나 기술 관련 이력서를 전문으로 하는 사람을 찾는게 좋다.  계약하기 전에 작업 샘플을 보여달라고 해라. 샘플은 소프트웨어 개발자용 이력서로 요구하라.  이력서 작성 전문가에게 주어야 할 정보는 다음과 같다          모든 관련 업무 경력의 정확한 날짜      각 일자리의 직함과 직무 내용      각 업무에서 성취한 주요 업적      모든 학력      각종 증명서와 수상 경력      가장 중요하다고 생각하거나 가장 큰 관련이 있다고 생각하는 기술 목록      자신이 하고 싶은 직무에 관한 몇 가지 직무 설명 샘플      그 외 관련이 있다고 생각하는 모든 것        몇 가지 다른 버전의 이력서를 만들어달라고 부탁하라. 자기소개서도 버전별로 완전히 다른 모습을 보여줄 수 있게 작성해달라고 하라.  간단명료하고 전문적이어야 한다. 적은 글로 더 많은 정보를 전달해야 더 깊은 인상이 남는다.  궁극적으로 자신이 어떤 기술을 갖추었고 어떤 분야가 전문인지, 그 기술로 과거에 어떤 훌륭한 결과를 냈는지, 그리고 지원하는 자리에서 그 기술을 어떻게 활용할지 아주 명확하게 보여줘야 한다.",
        "url": "//%EC%A0%84%EC%98%88%EB%A6%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/12/reading(2)-YR.html"
      }
      ,
    
      "ed-99-8d-eb-8f-99-ed-99-94-eb-b3-b5-ec-8a-b5-ec-9d-bc-ec-a7-80-2022-10-11-repeat-dh-html": {
        "title": "홍동화 복습일지",
        "tags": "",
        "date": "October 11, 2022",
        "author": "",
        "category": "",
        "content": "",
        "url": "//%ED%99%8D%EB%8F%99%ED%99%94/%EB%B3%B5%EC%8A%B5%EC%9D%BC%EC%A7%80/2022/10/11/Repeat-DH.html"
      }
      ,
    
      "ec-a0-84-ec-98-88-eb-a6-b0-eb-b3-b5-ec-8a-b5-ec-9d-bc-ec-a7-80-2022-10-11-reapeating-1-yr-html": {
        "title": "전예린 복습일지(1)",
        "tags": "",
        "date": "October 11, 2022",
        "author": "",
        "category": "",
        "content": "221011리차드슨의 REST 성숙도 모델레너드 리처드슨(Leonard Richardson)의 성숙도 모델은 REST의 성숙도를 총 4단계로 구분하는 유용한 모델이며, 2단계까지만 지켜져도 좋은 API 디자인이라고 한다.0단계에서는 server와 client간의 상호작용에 있어서 HTTP 프로토콜을 사용해야 한다.1단계에서는 개별 리소스(Resource)와의 통신을 준수해야 한다. 모든 자원은 개별 리소스에 맞는 엔드포인트(Endpoint)를 사용해야 하며, 요청하고 받는 자원에 대한 정보를 응답으로 전달해야 한다는 것이 핵심이다.2단계에서는 CRUD에 맞게 적절한 HTTP 메서드를 사용해야 한다. HTTP 메서드에는 GET, POST, PUT, PATCH, DELETE가 있다.마지막으로 3단계에서는 응답에 리소스의 URI를 포함한 링크 요소를 삽입하여 작성해야 한다.",
        "url": "//%EC%A0%84%EC%98%88%EB%A6%B0/%EB%B3%B5%EC%8A%B5%EC%9D%BC%EC%A7%80/2022/10/11/reapeating(1)-YR.html"
      }
      ,
    
      "ec-a0-84-ec-98-88-eb-a6-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-11-reading-1-yr-html": {
        "title": "전예린 독서일지(1): 커리어 스킬",
        "tags": "",
        "date": "October 11, 2022",
        "author": "",
        "category": "",
        "content": "22.10.02 일요일 31p~66p어떤 계획을 세워야할지, 어떤 개발자가 되고 싶은지 먼저 생각해라.프로그래밍 언어 한 가지를 익혀라. 어떤 언어를 배울지는 생각만큼 중요치않다.코드를 구조화 해라. 코딩을 처음 배울 때부터 깔끔하게 잘 작성하는 방법을 배워라(코드만으로도 의사 전달이 가능하게끔).알고리즘을 다양하게 변형하는 방법을 익혀라(알고리즘은 배우기 어렵지만 가치가 있음).개발 플랫폼 하나와 그와 함께 사용하는 기술 또는 프레임워크를 익숙하게 쓸 수 있어야한다. 선택한 프레임워크에 따른 전체 개발 스택을 배워라(스텍은 애플리케이션 하나를 제대로 완성하는데 함께 쓰이는 기술 세트를 말함).22.10.03 월요일 67p~86p어떤 기술이든 발전시키려면 시간이 든다. 연습해라. 시간이 오래걸리고 발전이 정체되고 있다고 느낄 때를 조심해라. 확실한 계획과 명확한 목표를 따라가는 한 기술은 분명 발전할 것이다.첫번째,두번째 프로그래밍 언어를 배울 때가 가장 어렵다. 프로그래밍 언어들은 공통점이 많으니 한 두개를 배워두면 점차 수월해질 것이다.지금은 라이브러리와 프레임워크를 어떻게 활용하느냐가 프로그래밍 언어를 깊게 아는 것보다 중요하다. 그러니 배우겠다고 선택한 언어가 어려워도 포기하지마라.22.10.04 화요일 87p~109p첫번째 프로그래밍 언어 배우기  잘 작동하는 애플리케이션 살펴보기프로그래밍을 배울 때 책을 찾는 것도 좋지만 잘 작동하는 애플리케이션의 소스 코드를 살펴보고(이왕이면 인기 있는 것. 설계가 잘 되어있을 가능성이 높기 때문) 코드가 어떤 역할을 하는지 느껴라.  몇 가지 참고자료 훑어보기(책,동영상,기사 튜토리얼 등)프로그래밍 관련 도서를 처음부터 끝까지 꼼꼼히 읽지 않아도 된다. 자신이 배우려는 언어의 범위, 기본 개념은 무엇인지 정도만 이해하자.  ‘Hello world’ 프로그램 만들기해당 언어를 제대로 배운다기보다 그 언어로 프로그램을 만들고 실행하는 데 필요한 기본 툴 체인을 익히고 테스트해보자.  기본 문법을 배우고 실제 문제로 테스트해보기  기능과 라이브러리 구분하기  특정 언어에서 언어와 라이브러리의 영역이 어떻게 나뉘는지 이해하고, 그 언어로 문제를 해결하기 위해 라이브러리를 찾는 법을 익혀라.  기존 코드 리뷰하고 한 줄씩 이해하기  무엇이든 만들어보기소소한 프로젝트 아이디어를 몇 개 골라 애플리케이션을 만들어라. 자신이 배운 프로그래밍 언어와 표준 라이브러리를 활용하는데 중점을 둔 단순한 애플리케이션을 만드는데 집중해라.프로그래밍 언어를 특정 기술이나 플랫폼에 적용해보기ex) 자바를 배우는 중이라면 안드로이드 프레임워크와 앱 작성 법 배운 후 안드로이드 앱 제작해보기  어려운 알고리즘 문제 해결해보기내가 풀지 못하고 끙끙대는 문제를 다른 사람이 어떻게 풀었는지 반드시 살펴볼 것. 처음엔 어려운게 정상이다. 시간이 지날수록 문제 유형에 익숙해지고 해결책도 즉시 떠오른다.22.10.05 수요일 110p~134p프로그래밍 독학 전략  무엇을 공부할지 계획을 세워라. 얼마의 기간을 들일지, 목표로 하는 수준에 이르기까지 구체적으로 어떤 단계를 거칠지도 계획하라.  일정표를 만들어라. 일정을 미리 정해두고 마치 거기에 목숨이 걸린 것처럼 지켜라.  공부하는 동안 인맥을 쌓아라.멘토를 찾아라. 소프트웨어 개발자 한 명 정도는 알고 지내는 게 좋다. 질문이 생길 때 물어보거나 꼭 필요할 때 도움을 청할 수 있는 사람 말이다.  사이드 프로젝트를 진행해라. 좋은 사이드 프로젝트는 다음과 같은 혜택을 제공한다.          배운 내용을 연습하고 적용해볼 문제 제공      포트폴리오 제작에 보탬이 됨      추가 소득이나 새로운 사업을 만들 가능성이 열림      코딩을 배우는 동시에 유용한 도구도 만들 수 있음      자신의 능력에 대한 자신감 키워줌      (이런 일을 좋아하는 사람에게는) 그 자체로 재미있음        플루럴 사이트 같은 곳에 가입하라(린다, 유데미, 트리우스 등과 비슷한). 혼자 체계적으로 공부할 수 있는 아주 좋은 방법이다.22.10.06 목요일 135p~159p인턴십거대 IT 회사는 보통 인턴이나 경력직 개발자만 고용한다. 해볼 기회가 생겼다면, 특히 막 입문할 즈음 그런 기회를 얻었다면 보수에 상관없이 그 기회를 꼭 잡아라. 인턴이되면 자신이 무슨 일을 해야 할지 스스로 알아내고 최소의 관리와 피드백만 받고도 일을 제대로 해야 한다. 다른 직원이 더 수월하게 일할 수 있게 노력해야 한다는 뜻이다.경력없이 일자리 구하기경력 없이 소프트웨어 개발자로 취직할 핵심 전략은 자신이 실제 코딩 능력을 갖추었다는 사실을 증명하는 것이다. 아직 업무 경력이 없어서 그렇지 프로그래밍 경력은 충분히 쌓았다는 사실을 확실히 보여주고 코딩 능력을 입증할 증거를 제시하면 된다.온라인에 존재감을 드러내라. 소프트웨어 개발자라면 블로그가 있어야 한다.작성한 코드와 참여한 프로젝트를 포트폴리오에 잘 녹여내라. 깃허브는 직장 경력이 부족할 때 자신의 능력을 증명할 수 있는 방법 중 하나다.포트폴리오에 최소 서너 가지 이상의 애플리케이션이나 프로젝트를 넣어라. 대단할 필요는 없지만 그렇다고 너무 사소한 건 곤란하다. 단위 테스트나 자동테스트도 포함해 테스트 코드를 작성할 능력이 있다는 것도 증명해라.자격증만으로 그 분야에 대한 지식을 증명하거나 일자리를 보장받기는 어렵다. 하지만 경력이 부족한 사람을 고용하며 느끼는 불안감은 경감시킬 수 있다.경력이 부족하다면 진취적인 태도로 이를 보충해야 한다. 상대에게 긍정적인 답을 얻을 때까지 끈질기게 매달리는 진취적인 사람이 돼라.",
        "url": "//%EC%A0%84%EC%98%88%EB%A6%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/11/reading(1)-YR.html"
      }
      ,
    
      "ec-9d-b4-ec-9c-a0-ec-a0-95-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-11-reading-yj-html": {
        "title": "이유정 독서일지(1장): 컴퓨터 내부의 언어 체계",
        "tags": "",
        "date": "October 11, 2022",
        "author": "",
        "category": "",
        "content": "20221004 화요일 p.51~p.55 언어의 뜻은 기호의 집합으로 인코딩되지만 결국 문맥이 중요하다.기호나 조합은 무궁무진한 가능성이 있다. 컴퓨터에서는 비트라는 2진법을 사용한다는 뜻의 바이너리와 숫자를 뜻하는 디지트가 합쳐진 말이 있다. / 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작을 논리연산이라고 한다. / 비트에 대해 사용할 수 있는 연산 규칙의 집합인 불리언대수가 있다. ‘NOT,AND, OR,XOR ‘, 진리표를 사용해 시각적으로 보여줄 수 있다. XOR은 (A OR B) AND (NOT (A AND B))를 뜻한다20221005 수요일 p.56~ P.62반 컴퓨터에서 입력을 항상 원하는 형태로 얻을 수는 없기 때문에 드모르간의 법칙이 유용할 때가 있다. 긍정적인 논리 ‘정논리’ 부정적인 논리 ‘부논리’ / 2진수는 2를 밑으로 하는 수 체계다. 10진수로는 5028이 네 자리 숫자고, 2진수로는 13비트 수가 된다. 10진수와 마찬가지로 2진수에서도 비트의 개수가 표현할 수 있는 값의 범위를 결정한다. 가장 작은 유효 비트를 LSB, 가장 큰 유효 비트를 MSB 라고 한다. 2진수에서도 각 비트를 LSB에서 MSB 쪽으로 더하며 결과가 1보다 크면 1을 다음 왼쪽 자리로 올린다.001 + 101 = 110 . 서로 더한 결과는 두 비트를 XOR 한 값과 같고, 올림은 두 비트를 AND 한 값과 같다. 한 연산에서 올림까지 포함해 3개의 비트를 더하고 있다. 덧셈 결과가 비트의 개수로 표현할 수 있는 범위를 벗어나면 오버플로가 발생한다. 즉, MSB에서 올림이 발생했다는 뜻이다. 1001 과 1000을 더하면 10001이지만 왼쪽에 사용할 수 있는 비트가 없기 때문에 결과가 0001이 된다.컴퓨터에 조건코드 레지스터 라는 것이 있어서 몇가지 이상한 정보를 담아둔다. 이런 정보 중에는 오버플로 비트가 있고, 이 비트에는 MSB에서 발생한 올림값이 들어간다. 이 비트값을 보면 오버플로가 발생했는지 알 수 있다.20221006 목요일 p.62반 ~ p.69 2진수로 음수를 표현하는 방법을 살펴보자! / 음수와 양수를 구별하기 위해 부호를 사용한다. 우리는 가장 왼쪽 비트(MSB)를 부호에 사용하기로 멋대로 결정했다. 비트가 0이면 양수로 취급, 부호 비트가 1이면 음수로 취급하자. 그렇게 4비트로 총 15가지 음수와 양수를 표현할 수 있다. 이처럼 한 비트를 부호에 사용하고 나머지 비트를 수의 크기를 표현하는 방법을 부호와 크기 표현법이다. 이 사용법은 0을 표현하는 방식이 두가지라 비용 낭비고, XOR과 AND를 통한 덧셈 계산을 사용할 수가 없다. +1 과 -1을 더하고 싶어서 0001 + 1001 을 더하면 1010 이 되는데 이는 -2 값이 된다. 0이어야 하는데 !!!!! / 1의 보수 표현법을 알아보자. 이는 양수의 모든 비트를 뒤집는 방법이다. 7을 표현하기 위한 방법은 0111 인데, -7을 표현하기 위한 수는 1000 이렇게 된다.이 표현법은 0을 두가지 방식으로 표현하고, MSB 쪽에서 올림이 발생한 경우에는 LSB로 올림을 전달해야 하고, 이를 순환 올림이라고 부른다. 덧셈 할때 잘 작용하나 약간 복잡하다. / 2의 보수 표현법을 알아보자 !!!! 어떤 수의 모든 비트를 다 뒤집고 거기서 1을 더해준다. 0을 표현하는 방법은 하나뿐이다! 2의 보수로 표현할 수 있는 값의 범위는 비트 개수가 늘어날 때마다 지수적으로 증가한다. / 실수를 표현하는 방법도 알아보자. 그 중에 고정소수점 표현법 !!! 2비트는 2진 소수점의 오른쪽에 있는 분수들을 표현하는 데 쓰고, 2비트는 왼쪽에 있는 숫자들을 표현하는데 쓴다. 잘 작동하지만 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많다. DSP 디지털 신호 처리 장치 등 특별 목적에 쓰이는 일부 컴퓨터는 쓰기도 한다. 그러나 범용컴퓨터는 플랑크 상수부터 아보가드로 수까지 표현할 수 있는 범위를 표현할 줄 알아야 하며, 고정소수점 표현법으로는 200비트정도가 필요하고 비용이 너무 많이 든다20221008 토요일 p.70 ~ p.76반 부동소수점 표현법으로 과학적 표기법을 2진수에 적용한다. 수를 새롭게 해석하는 방법인데 10진수 소수점 왼쪽이 한 자리 뿐인 소수에 10을 몇번 거듭제곱한 값을 곱하는 방식으로 소수를 표현한다. 가수 부분은 2진 소수, 지수 부분은 2의 거듭제곱 횟수를 표현한다. 소수점의 위치가 같아보이지만 지수가 무엇인가에 따라 소수점 왼쪽 숫자의 자리가 1/10 일수도, 100,000일수도 있다.소수점 위치가 정해져 잇지 않다고 말할 수 있다. 부동소수점 2진수 예시 1.101 이를 보면 비효율성을 알 수 있다. 모든 수를 표현하지도 못하고 가수의 한 패턴과 다른 패턴 사이의 값 차이가 커진다.이 부정확한 계산을 어떻게 개선할지 수치해석이라는 수학 분야가 있긴하다. /부동소수점 수 시스템은 실수를 표현하는 표준 방법이고, 더 많은 비트를 사용하고, 각각 부호 비트를 사용한다. 다만 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있다. 낭비되는 비트 조합을 최소화하고 반올림을 쉽게 하는 IEEE 754 라는 표준이 있다. 정밀도를 높이고 싶어서 가수를 조정해서 맨 앞에 0이 없게 만드는 정규화를 실행한다. 두번째 트릭은 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략하는 것이다. 기본 정밀도 부동소수점 수가 있고, 2배 정밀도 부동소수점 수가 있다. 비트를 2배나 더 많이 사용한다는 비용을 지불한다. 이것들은 지수에 대해 부호 비트가 따로 존재하지 않는다. 편향값을 갖게 했다. 기본 정밀도의 편향값은 127 2배 정밀도 수의 평향값은 1023이다. 특별한 지숫값을 부여해 NaN 도 표현할 수 있다. / 2진 코드화한 10진수 시스템이 있다. 12를 BCD로 표현하면 0001 0010 이다. 디스플레이나 가속도 센서 등이 BCD를 이용한다. 2진수를 효율적으로 활용하지 못한다. /2진수를 다루는 쉬운 방법에 8진 표현법과 16진 표현법이 있다. 8진 표현법은 2진수 비트들을 3개씩 그룹으로 묶는다. 과거처럼 널리 쓰이진 않는다. 2진수를 표현하기 위해 쓰이는 수는 0과 1 두개이고, 8진수를 표현하고 위해 필요한 수는 0 ~ 7 8개가 필요하다. 16진수를 표현하기 위해선 0~15 숫자가 필요하다.10,11,12,13,14,15 는 A,B,C,D,E,F 로 각각 표현한다 , /수를 변환하는 방법을 어떻게 표현할까? 0으로 시작하는 숫자는 8진 숫자다. 1부터 9 숫자로 시작한느 숫자는 10 진수다.0x가 앞에 붙은 숫자는 16진수다.20221009 일요일 p. 76반 ~ p.81 컴퓨터는 제대로 조직화된 비트들로 이뤄진다. 따라서 컴퓨터가 사용할 비트의 개수와 비트들의 조직을 결정해야 했다. 비트는 너무 작아서 기본 단위로 사용하기에는 유용성이 떨어진다. 따라서 비트를 좀 더 큰 덩어리로 만들었는데, 8비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 바이트라고 부른다. 큰 수를 가리키기 위해 사용하는 표준 용어도 존재한다.키비, 메비, 기비, 테비 는 순서대로 2의 10제곱, 2의 20제곱, 2의 30제곱, 2의 40제곱을 뜻한다. / 컴퓨터는 항상 비트를 다루고 비트를 사용해 수와 같은 대상을 표현한다.아스키코드는 모든 기호에 대해 7비트 수 값을 할당했다. 65는 대문자 A을 나타낸다. a는 97이다. 아스키 코드 표에서 글자를 출력하는데 쓰이지 않고 장치를 제어하기 위해 쓰이는 제어문자도 있다. 이 중 상당수는 통신 제어를 위한 문자다. 비트 가격이 떨어짐에 따라 문자에 16비트 코드를 부여하는 유니코드라는 새로운 표준이 만들어졌다. 그 후 21비트까지 확장됐지만, 이조차도 충분하지 않을 수 있다. 유니코드 변환 형식 8비트 UTF-8 ,,, 유니코드는 문자 코드에 따라 각기 다른 인코딩을 사용해 굳이 16비트를 쓰면서까지 비트 낭비를 막는 문제를 해결한다. 인코딩은 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴을 뜻한다. UTF-8은 모든 아스키 코드를 8비트로 표현하기 때문에 아스키 데이터를 인코딩 할 때는 추가 공간이 필요하지 않다. 그리고 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩한다.20221010 월요일 p. 82~ p. 83 UTF-8은 8비트 덩어리의 시퀀스로 인코딩한다. 첫번째 덩어리의 MSB 쪽에 있는 비트들이 8비트 덩어리 시퀀스의 길이를 표현하고 덩어리의 맨 앞을 식별하기 쉽다. 모든 아스키 문자는 7비트에 들어가기 때문에 덩어리를 하나만 사용해 표현할 수 있다.UTF-8로 인코딩할 때 7비트 안에 문자의 코드가 다 들어가기 때문에 덩어리를 하나만 사용하고 MSB를 0으로 설정한다.2개의 8비트 덩어리를 사용할 때는 첫번째 덩어리의 MSB 3비트 를 110으로 시작하고, 두 번째 덩어리의 MSB 2비트는 10으로 시작한다. / UTF-8은 문자 A를 표현하는 비트들 2진수 0000000001000001 로부터 나온 숫자들 0x0041 을 표현하는 숫자들 즉, UTF-8 을 표현하기 위해 실제 UTF-8 로 인코딩한 0x41을 사용한다. 이제는 문자를 사용해 수를 표현할 수도 있다. 2진 데이터를 직접 보내는 것은 어렵다. 아스키 코드 중 상당수가 제어 문자로 되어있고, 이를 처리하는 방식이 달라야 했기 때문이다.20221011 화요일 p. 83 반~ p. 85 출력 가능하게 변경한 인코딩은 쿼티드 프린터블 인코딩, QP 인코딩이라고도 한다.8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법이다. 이 인코딩을 사용하면 = 다음에 바이트의 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트 값을 표현한다. QP에서는 = 를 =3D 로 사용해야 한다. QP 인코딩 추가 규칙이 있다. 줄의 맨 끝에 탭과 공백 문자가 온다면 =09 =20 으로 표현해야만 한다. 인코딩된 데이터는 한 줄이 76자를 넘을 수 없다. 어떤 줄의 맨 뒤가 =로 끝나면 가짜 줄바꿈을 뜻한다. 수신 쪽에서 QP로 인코딩 된 데이터를 디코딩 할 때는 이 =를 제거하고 해석한다./ ‘베이스64 인코딩’ QP 인코딩이 잘 작동하기는 하지만 1바이트를 표현하기 위해 3바이트를 사용한다. 그래서 비효율적이다. 베이스64 인코딩은 3바이트 데이터 총 24비트를 4개의 6비트 덩어리로 나눈다. 각 덩어리의 비트를 출력 가능한 문자를 할당해 표현한다. 이 인코딩은 모든 3바이트 조합을 4바이트 조합으로 변환할 수 있다. 원본 데이터 길이가 3바이트의 배수라는 보장은 없으니, 패딩 문자를 도입한다. 원본 데이터가 2바이트 남으면 끝에 = 를 붙이고, 1바이트 남으면 끝에 ==를 붙인다. / ‘URL 인코딩’ =가 특별한 기능에 해당하지 않을 때도 있다. %26 이나 %2F 가 이에 해당한다. 이런 값이 있는 이유는 URL 이라는 문맥에서 몇몇 문자가 특별한 의미를 지니기 때문이다. 이런 것들은 리터럴로 사용한다.URL 인코딩은 퍼센트 인코딩이라고도 부르는데, % 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩한다. 예를 들어 슬래시 문자는 URL에서 특별한 의미를 지닌다.이 문자의 아스키 코드는47, 16진수로는 2F다. /를 URL에 사용하되 /가 표현하는 특별한 의미를 뜻하고 싶지는 않은 경우, /를 %2F라는 문자열로 대신한다.20221016 일요일 p. 86 ~ p.90 색 표현을 할 때도 숫자를 사용한다. 컴퓨터 그래픽스는 전자 모눈종이에 점을 찍어서 그림을 만드는 과정이다.각 격자에 찍는 점을 그림원소라 부르고, 픽셀이라 줄여 말한다. 빨, 노 , 파 광선을 섞어서 컴퓨터 모니터가 색을 만들어낸다.RGB 색 모델. 값이 0이면 빛을 끄고, 값이 1이면 빛을 킨다. 아무 빛도 없으면(0,0,0) 검은색이고, 모든 빛을 최대로 켜면(1,1,1) 흰색이다. 이처럼 빛을 혼합해 색을 표현하는 방식을 가산 색 시트템이라고 한다. 특정 빛의 광선(파장)을 서로 추가해 색을 만든다. 가산 색 시스템은 주 색이 청록색, 자홍색, 노란색이며 흰색 광선에서 각 색에 해당하지 않는 빛을 제거하면서 색을 만들어낸다. 가산 시스템이 더 많은 색을 만들어낸다.인간의 눈은 생존을 위해 진화해온 아주 지저분한 기계장치다. 우리의 구분은 선형적이지 않으며, 전체적인 빛의 세기에 맞춰 눈의 응다바이 점차 변한다. 암순응이다.dark adaptation / 현대 컴퓨터는 색을 표현하는 데 24비트를 사용하고, 8비트로 나뉘며, 이 각 필드는 세가지 주요 색을 표현한다. 그러나 현대 컴퓨터가 24비트 단위로 계산을 수행할 수 없어서 32비트에 색을 넣어서 처리한다. 이때,, 사용하지 않는 8비트를 낭비하지 않기 위해 투명도를 표현하기로 한다. / 투명도 추가! 각 픽셀에 a라는 투명도 값을 추가했다. 알파는 수학적으로 0이상 1이하인 값이다. 0은 해당값이 완전히 투명하다는 뜻이고, 1은 완전히 불투명하다는 것이다. 여러 다른 알파값의 색을 합성해 새로운 색을 만들어내는 이 방법을 합성 계산법이라고 한다. 알파 값으로 1부터 255의 값을 사용했다. 빨, 노, 파 색 값을 그대로 저장하는 대신, 색값에 알파를 곱한 값을 저장했다. RGB로 빨간색이 200,0,0 이라면 투명도를 0.5로 하고 싶다. 그러면 100,0,0 의 값에 255*0.5 = 127 알파 값은 127이다. 알파값을 미리 곱한 값을 저장한다는 말은 픽셀을 사용할 때마다 알파를 곱하는 계산을 반복할 필요가 없다는 뜻이다. 색 인코딩 ! 텍스트를 이용해 색을 표현하기 위해선, 16진 트리플렛으로 표현한다. #rrggbb 이렇게 8비트 색값을 두자리 문자로 된 16진 표기로 바꾼다. / 정리! 비트를 사용해 숫자, 문자, 색을 표현하는 방법을 배웠다. 2장에서는 컴퓨터를 이루는 물리적 구성요소를 이해하고 왜 컴퓨터가 애초부터 비트를 사용하는지 이해할때 도움이 될 수 있도록 하드웨어 기본을 배운다!!!!!!",
        "url": "//%EC%9D%B4%EC%9C%A0%EC%A0%95/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/11/reading-YJ.html"
      }
      ,
    
      "ec-9d-b4-ec-98-81-ec-9a-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-11-reading-yw-html": {
        "title": "이영우 독서일지",
        "tags": "",
        "date": "October 11, 2022",
        "author": "",
        "category": "",
        "content": "1일차 8p ~ 14p깨끗한 코드는 테스트 케이스가 존재하는 코드이며, 문학적인 코드여야 한다.깨끗한 코드란 작성자가 아닌 다른사람들도 쉽게 읽을수 있으며, 고칠수 있는 코드여야한다.2일차 15p ~ 21p프로그래머란, 프로그래밍 언어를 단순하게 보이도록 만드는 열쇠 같은 존재다.깨끗한 코드란, 예상한 대로 작동하는 코드이며, 이런 코드를 짜기위해 정성을 들여서 코드를 작성해야한다.",
        "url": "//%EC%9D%B4%EC%98%81%EC%9A%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/11/reading-YW.html"
      }
      ,
    
      "ea-b0-95-ec-a7-84-ec-9b-90-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-10-reading-jw-copy-html": {
        "title": "독서일지",
        "tags": "",
        "date": "October 10, 2022",
        "author": "",
        "category": "",
        "content": "2022-10-10 (1)좋은 프로그래머란 ?  좋은 프로그래머는 좋은 비판적 사고와 분석 기술을 지녀야 한다.  작동할 뿐만 아니라 다른 사람들이 이해하고 유지보수 하기 쉬운 코드를 작성해야한다.  컴퓨터 작동을 잘 이해해야 한다. &lt;/br&gt;컴퓨터란 무엇인가?  컴퓨터(하드웨어)는 다양한 프로그램과 상호작용을 하며 다양한 일을 수행할 수 있다.  예를 들면 웹 페이지를 볼 때는 컴퓨터만 쓰는 것이 아니라, 컴퓨터에서 실행되는 누군가가 미리 작성해둔 프로그램, 웹 페이지를 호스팅하는 컴퓨터, 그리고 그 두 컴퓨터 사이에서 인터넷이 작동하도록 돕는 모든 컴퓨터를 통해 웹 페이지를 본다. &lt;/br&gt;컴퓨터 프로그래밍이란 무엇인가?  컴퓨터를 가르치는 것. 프로그래머는 일종의 선생님이 되어 컴퓨터가 일을 처리 할 수 있도록 가르치는 것을 프로그래밍이라고 한다. 컴퓨터는 수많은 일을 처리 해야 하기에 프로그래머 또한 첫번 째 단계로 가능한 모든 분야를 많이 배우는 것이 좋다. 컴퓨터는 단순히 일을 처리 하는 기계이다. 프로그램은 원하는 작업을 컴퓨터가 처리 할 수 있도록 한다. 컴퓨터가 이해할 수 있도록 가르치고 그것을 수행하도록 하는 것.   결국에 컴퓨터가 수많은 일을 처리 할 수 있도록 프로그래밍하기 위해선 프로그래머 또한 우주를 이해하듯이 많은 분야에 대해 관심을 갖고 이해하려고 노력해야한다. &lt;/br&gt;2022-10-12 (2)   요즘엔 보편적으로 애플리케이션 프로그래밍을 많이 배우고 있다. 하지만 우리는 시스템 프로그래밍에 대해서 알 필요가 있다. 시스템 프로그래밍을 하려면 하드웨어와 친해져야 한다.우리는 어떤 문제에 직면했을 때 그 문제를 보다 근본적으로 해결하기 위한 방법을 찾으려면 논리, 전자회로 등 컴퓨터에 대해 전반적으로 이해할 필요가 있다.좋은 프로그래머란 하드웨어와 소프트웨어의 합일을 추가하는 테크노 요기(요가 수행자)이다. 핵심 기술을 이해하면 높은 수준에서 더 나은 해법을 생각해 낼 수도 있다. 2022-10-13 (3) 51p ~ 57p   프로그래머가 해야 할 일은 컴퓨터에게 명령을 내리는 것이다. 그렇다면 컴퓨터에게 명령을 내리려면 어떻게 해야 할까? 컴퓨터 언어를 알아야 한다. 우선 컴퓨터에서는 2진법을 뜻하는 ‘바이너리(binary)’와 숫자를 뜻하는 ‘디지트(digit)’가 합성된 언어로 ‘비트’를 사용한다. 또 컴퓨터에서는 논리연산을 다루는데, 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 이런 동작을 논리연산이라고 한다.  |질문|답변||—|—||밖에 눈이 오는가?|예/아니오|2022-10-22 토요일 (4) 57p~62p정수를 비트로 표현하는 방법앞서 컴퓨터는 2진법을 뜻하는 ‘바이너리(binary)’와 숫자를 뜻하는 ‘디지트(digit)’가 합성된 언어로 ‘비트’를 사용 한다고 했다. 그러면 이 비트로 숫자를 어떻게 나타낼 수 있을까? | | | | ||합||-|-|-|-|-|-||10진수|103|102|101|100||||1000|100|10|1|1111||2진수|23|22|21|20||||8|4|2|1|15||자리수 하나당 1비트라고 했을 때|비트|비트|비트|비트||숫자 15를 2진수로 나타내려면 23+ 22+21+20 =&gt; 4비트컴퓨터는 2진수를 사용한다. 자리를 표현하는 박스하나하나가 비트를 나타낸다. 예를 들어 5028이라는 10진수의 숫자를 2진수로 나타내면 |212|211|210|29|28|27|26|25|24|23|22|21|20|합||-|-|-|-|-|-|-|-|-|-|-|-|-|-|1|0|0|1|1|1|0|1|0|0|1|0|0||4096|0|0|512|256|128|0|32|0|0|4|0|0|5028즉 5028을 비트로 표현하면 (1001110100100) 1과 0으로 된 13자리의 숫자로 표현이 가능하다 =&gt; 13비트가장 왼쪽 비트(NSB : 가장 큰 유효비트)가장 오른쪽 비트(LSB : 가장 작은 유효비트)-정리 컴퓨터에서는 정수를 비트로 표현 할 수 있다. 위는 컴퓨터가 숫자를 인식하는 원리에 대한 설명이다.2022-10-23 일요일 (5) 62p~72p실수를 비트로 표현하는 방법밑이 10인 실수에는 10진 소수점이 포함된다. 따라서 밑이 2인 경우도 실수를 표기하기 위해 2진 소수점을 표현할 방법이 필요하다.  고정소수점 표현법  부동소수점 표현법-고정소수점 표현법 예를 들어 4비트가 있다면 소수점을 기준으로 왼쪽 2비트는 정수부분을, 오른쪽 2비트는 분수 부분을 표현 한다. 소수점의 위치가 항상 일정하기 때문에 이런 방식을 고정소수점 표현법이라 한다. 고정 소수점 표현법은 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많기 때문에 범용 컴퓨터에서 이런 방식을 사용하는 경우는 드물다. 디지털 신호 처리장치(DPS:digital signal processor)등 특별한 목적에 쓰이는 일부 컴퓨터는 여전히 고정소수점을 쓰기도 한다. -부동소수점 표현법 넓은 범위의 값을 2진수로 표현하기에 고정소수점 표현법은 제한이 있다. 이를 위해 과학적 표기법을 2진수에 적용하낟. 일반적으로 0.0012 대신 1.2x10-3이라고 쓰며, 이 값은 1.2x0.001이므로 0.0012와 같다. 2진법으로 표기할 때는 10이 아닌 2를 밑으로 한다는 점만 다를 뿐이다. 가수부분은 2진 소수, 지수부분은 2의 거듭제곱으로 수를 표현한다. 부동소수점 표현법은 지수와 가수를 분리함으로써 수를 표현할 때 필요한 0을 모두 저장하지 않고도 큰 수나 작은 수를 표현 할 수 있다. -IEEE부동소수점 표준 2가지 부동소수점 수가 자주 쓰인다. 하나는 기본 정밀도 부동소수점(32비트: ±10의±38정도의 범위를 7비트로 표현할 수 있고), 다른 하나는 2배 정밀도 부동소수점(64비트:±10±308승의 넓은 범위를 고작 15비트 정밀도로 표현할 수 있다.)  -정리2진법으로 실수를 표현할 때, 고정소수점 표현법 같은 경우는 넓은 범위의 숫자를 비트로 표현하는데 어려움이 있다. 그에 대한 대안으로 부동소수점으로 광범위한 범위를 비트로 표현할 수 있다.2022-10-24 월요일 (6) 74p~81p2진수를 다루는 쉬운방법앞서 2진수로 정수와 실수를 표현하는 방법에 대해 배웠다. 2진수로 큰 수를 표현하면 1과0의 개수가 엄청나게 많아져 사용하는데 불편함이 있다. 그래서 사람들은 2진수를 조금 더 쉽게 다루기 위해 다양한 방법들을 찾아낸다. 그 방법중 8진 표현법, 16진 표현법등이 있으며 16진 표현법 같은 경우 요즘 컴퓨터 내부가 8비트의 배수를 사용해 만들어지기 때문에 16진 표현법이 쓰이고 있다. 비트는 너무 작아서 기본 단위로 사용하기에는 유용성이 떨어진다. 따라서 비트를 좀 더 큰 덩어리로 조직화 해야될 필요성을 느꼈고, 현재 세계적으로 8비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 이를 바이트라고 부른다. |이름|비트개수||–|–||니블(nibble)|4||바이트(byte)|8||하프 워드(half word)|16||워드(word)|32||더블 워드(double word)|64|워드는 각 컴퓨터가 설계상 자연스럽게 사용할 수 있는 비트 묶음의 크기를 가리키는 말로 쓰이고, 자연스럽게 쓸 수 있다는 말은 컴퓨터가 빠르게 처리할 수 있는 가장 큰 덩어리를 뜻한다.컴퓨터는 항상 비트를 다루며  비트를 사용해 수를 표현할 수 있게 되었다. 이제 이 수를 사용해 텍스트를 표현하게 된다.초기에는 아스키 코드(미국)를 사용했고, 점차 컴퓨터가 세계적으로 보편화가 되면서 여러 언어의 표현이 필요해졌다. 그리하여 시간이 지나면서 유니코드라는 새로운 표준이 만들어지게 된다. ",
        "url": "//%EA%B0%95%EC%A7%84%EC%9B%90/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/10/reading-JW-copy.html"
      }
      ,
    
      "ed-99-8d-eb-8f-99-ed-99-94-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-09-reading-dh-html": {
        "title": "홍동화 독서일지: 모던 자바스크립트 Deep Dive",
        "tags": "",
        "date": "October 9, 2022",
        "author": "",
        "category": "",
        "content": "📌 1일차 [ 04장 변수 ]선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다. 자바스크립트 코드는 한 줄씩 순차적으로 실행(런타임)되므로 console.log(score)가 먼저 실행되어 참조에러가 발생할 것 같지만 undefined가 출력된다.  변수 선언이 런타임이 아니라 그 이전단계에서 먼저 실행되기 때문  자바스크립트 엔진은 한 줄씩 실행하기에 앞서 소스코드의 평가과정을 거친다. 이때 모든 선언문을 소스코드에서 찾아내 먼저 실행한다.  그리고 평가 과정이 끝나면 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.위의 사진은 그 증거가 된다.이처럼 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 한다.변수 선언뿐 아니라 ver, let, const, function, class 등 모두 호이스팅 된다.&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;📌 2일차 [ 05장 표현식과 문 ]&lt;/br&gt;&lt;/br&gt;🌹 리터럴  리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.🌼 표현식  값으로 평가될 수 있는 문(statement)표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.🌸 문  token : 문법으로 더 이상 나눌 수 없는 단위 (var, sum, =)문 = 프로그램의 최소 단위(문은 여러 토큰으로 구성된다.)문 ? 선언문 / 할당문 / 조건문 / 반복문&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;표현식인 문과 아닌 문// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.var x;// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.x = 1 + 2;// 표현식이 아닌 문은 값처럼 사용할 수 없다.var foo = var x; // SyntaxError: Unexpected token var선언문이라서 값으로 평가될 수 없기 때문에, 즉 식이 아니기 때문에 에러가 난다.// 변수 선언문은 표현식이 아닌 문이다.var x;// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.x = 100;x = 100 할당문은 자체가 표현식이다. 숫자 값 100으로 평가된다.// 표현식인 문은 값처럼 사용할 수 있다var foo = x = 100;console.log(foo); // 100x = 100이 값 100으로 평가되어 100값이 foo변수에 다시 할당된 것이다.  개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데, 이를 완료 값이라고 한다.  완료값은 표현식의 평가 결과가 아니며 따라서 다른 값과 같이 변수에 할당할 수 없고 참조도 할수 없다.  개발자 도구에서 표현식인 문을 실행하면 언제나 평가된 값을 반환한다.",
        "url": "//%ED%99%8D%EB%8F%99%ED%99%94/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/09/Reading-DH.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-09-repeating-web-structure-html": {
        "title": "윤태연 복습일지(1)",
        "tags": "윤태연",
        "date": "October 9, 2022",
        "author": "",
        "category": "",
        "content": "웹의 구조: 2022 / 10 / 11사례윤태연은 코트를 사고싶어 크롬 주소창에 무신사 URL인 https://www.musinsa.com/app/ 를 쳐서 무신사로 접속하였고, 검색해 코트의 카테고리를 본다음 이것 저것 장바구니에 담지만 결국 사지는 못하고 짠한 잔고만 본다.설명여기서 윤태연과 윤태연이 쓰는 크롬브라우저는 사용자, 즉 클라이언트를 의미한다. 그러면서 원하는 사이트의 URL(도메인)을 입력하여 서버에게 요청한다. 서버는 이를 승인하고 윤태연이 봐야하는 홈페이지의 데이터를 클라이언트에게 보낸다. 그 뿐만 아니라 클라이언트가 접속한 후 요청하는 명령이 쏟아지기 시작한다?!  검색 요청  카테고리의 아이템 목록 불러오기 요청  전체보기 시 추가 아이템 요청  장바구니 담기 요청 등등이처럼 1. 클라이언트가 요청을 보내고, 2. 서버가 받는 구조는 웹이 기본적으로 통신하는 구조다. 이를 이중으로 상호작용하는 구조라 해서 ‘2티어 아키텍쳐’라고 명명한다.또한 ‘무신사’는 트래픽이 다량 발생하는 큰 웹이기때문에 2티어 아키텍쳐로는 서버만으로는 로딩 속도도 떨어지고, 불러올 수 있는 리소스양이 적는 등 규모가 커질 시 생기는 문제가 발생할 것이다. 그래서 서버가 바로바로 가져올 수 있는 ‘DB’라는 것을 따로 둬 요청시 서버가 바로바로 요구에 맞는 리소스를 빼와서 넣을 수 있게 만든다. 이것이 ‘3티어 아키텍쳐’다!",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/09/Repeating-Web-Structure.html"
      }
      ,
    
      "about-2022-10-09-asterisk-html": {
        "title": "모두의 실력이 곱해지다!",
        "tags": "",
        "date": "October 9, 2022",
        "author": "",
        "category": "",
        "content": "스터디 그룹 Asterisk입니다!매주 월요일 저녁 8시(공휴일일 경우 가장 가까운 평일에!)에 알고리즘 풀이와 복습한 내용을 공유하며 서로 꾸준하게 성장하고자 합니다!모두 수료와 취뽀까지 함께 달립시다! 주요 활동은 다음과 같습니다.  독서일지  복습일지  알고리즘세 가지 모두 화이팅합시다! 독서일지일주일에 주 3회 책을 읽고 내용 및 감상을 자유롭게 적어 주세요.형식은 상관없습니다! 주에 세 번만 꼭 해 주세요.복습일지일주일 동안 배운 내용 중 깊게 공부하고픈 내용에 대해 작성합니다.월요일에 문제 풀이 발표하지 않으신 분들은 자동으로 복습일지 발표자가 됩니다.다른 분들께 충분히 설명하고 질문을 받을 수 있도록 충분히 준비합시다!알고리즘일주일에 세 문제씩 풀고 모두 모여 풀이과정을 공유하는 시간입니다! 자세한 사항은 다음 리포지토리를 참고해 주세요.알고리즘 리포지토리",
        "url": "//about/2022/10/09/Asterisk.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-06-ec-98-a4-ea-b0-9c-ec-95-88-eb-a7-902-html": {
        "title": "윤태연 독서일지: 오개안말(2)",
        "tags": "윤태연",
        "date": "October 6, 2022",
        "author": "",
        "category": "",
        "content": "1-2. 온몸으로 느낀 개발자: 2022 / 10 / 06Part1. 가깝고도 먼 개발자2. 온몸으로 느낀 개발자여기선 개발자가 아닌 포지션이 개발자를 관찰하여 알게된 것을 사례로 3가지를 들며 서술하고있다.  자주 부정적 개발자(상황을 고려해 대안 제시)  매우 긍정적 개발자(오히려 무서움, 확실한 조건 걸기)  대안 제시 개발자(상황 인지해 대안 제시)다양한 유형이 있지만 쨌든 좋은 개발자는 ‘회사의 성장을 위해 협업해 문제를 해결하는 개발자’라는 것이다. 그런 개발자의 특징을 4가지로 나눈다.  집요한 문제 해결(문제 해결에 집요, 해결함으로써 즐거움을 느낌)  비즈니스 이해하는 눈(고객 관점 중시, 비즈니스 모델 추구 및 빠른 테스트)  5살배기도 이해하는 소통의 기술(어려운 개발 용어를 쉽게 풀어서) 4. 체계적 업무 관리와 빠른 피드백(업무 일정 내 마감, 변수에 빠른 피드백)또한 다른 포지션들에게도 3가지 교훈을 던져준다. 개발자들이 그냥 말에도 그렇게 ‘느낄 수 있는’ 포인트를 던져준다.  간단하죠? 해주세요(상대방 역할 무시 어투, 하나 버튼 추가에 복잡한 기능 연결)  ~까지 해주세요(개발자 입장 고려 X)  타 서비스는 제공하던데요?(타 개발자와 비교 어투, 안된다는 것엔 여러 이유 존재)",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/06/%EC%98%A4%EA%B0%9C%EC%95%88%EB%A7%902.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-03-ec-98-a4-ea-b0-9c-ec-95-88-eb-a7-901-html": {
        "title": "윤태연 독서일지: 오개안말(1)",
        "tags": "윤태연",
        "date": "October 3, 2022",
        "author": "",
        "category": "",
        "content": "1-1. 어딘가 이상한 비전공자의 협업: 2022 / 10 / 03Part1. 가깝고도 먼 개발자1. 어딘가 이상한 비전공자의 협업IT업계 회사엔 개발, 기획, 디자인 등 다양한 인력들이 모여 협업을 이룬다. 그 중 개발자와의 협업을 제일 어려워 하는 이야기가 많이들 나온다. 왜 이런 것일까? 그 답은 개발 언어가 거의 외국어 수준이여서 소통이 안되는 점, 개발이 어떻게 되는지에 대한 과정 및 구조를 전혀 알 수 없어서 나온다. 결국 기획하고자 하는 의도, 웹 구조에 의한 웹 디자인 등 기본적인 개발을 알아야 원활한 소통이 가능하다. 즉 협업의 기본은 최소한 개발에 대해 과정과 구조를 겉으로도, 피상적인 이해가 있어야 협업이 가능하다. 그러므로 자신의 회사에 필요한 기술 스택을 알고, 협업에 필요한 개발 지식을 학습하여 원활한 협업을 요하는 것이 중요하다!전체 내용 정리Part1. 가깝고도 먼 개발자1. 어딘가 이상한 비전공자의 협업- 기획자 김 군의 협업행정학과 김 군, 교내 스타트업 스타팅 멤버로 PT 할 수 있다는 이유로 취업, 서투른 기획서로 서비스 기획을 하며 개발자와 협업, 규모가 작아 서로의 의도를 잘 파악할 수 있는 구조라 원만한 협업 가능, 협업 중 기획하고자 하는 의도, 즉 ‘메시지’가 중요하다는 걸 김 군은 깨달음하지만 클라이언트(고객)와도 소통이 필요, 만일 WIFI를 사용하는데 광고를 봐야 사용 가능케 하는 서비스를 제작해 팔아 지점마다 설치하는 서비스를 김 군이 기획, 영업, 유지•관리함, 그런데 만일 클라이언트에 문제가 생기거나 해주지 못할 요청사항 등 김 군이 커트해야할 문제들을 관리해야하는데 화면 관리의 프론트엔드, 서버의 백엔드, WIFI의 펌웨어, 네트워크 등 다양한 기술 문제를 모른다면 관리하지 못함또한 개발자들끼리의 생각이 달라 기획자로서 조율해아하는 문제에 부닥칠 수도 있음, ‘프엔 개발자는 된다지만 백엔 개발자는 기능 구현이 안된다.’ 식의 문제에 직면할 수도 있음, 하지만 백엔드 개발자가 기능 성장을 저해한다든지 그런 의미가 아님, 서비스 운용의 관점이 다르거나 어떠한 문제로 부딪혀 부정적인 생각을 내비치는 것일 수도 있음즉! 기획자는 개발 구조를 이해해 전체적인 개발 흐름을 알고, 개발자와의 소통을 하는데 있어 문제의 대안이나 더 좋은 서비스로 성장하자는 의도 등 유연한 사고방식을 가져 개발자와 보다 더 나은 파트너의 관계로 발전해 나갈 수 있다.- 디자이너 김 양의 협업중장기 계획을 짜고 사업의 전체적인 전략을 짜는 소규모 IT기업의 전략기획부로 입사한 김 양, 하지만 김 양은 디자인 툴과 블로그 경험이 있어 입사한 터라 간단한 디자인 업무와 마케팅 업무를 도맡아 했음, 그러다 대행 판매 건을 맡게 됐고 페이지가 필요해 개발이 필요한 ‘랜딩 페이지’를 디자인해 개발팀에게 전달했고 당연히 반려당함 - 웹 개발에 기반하지않은 디자인 기획(구역, 모션 등), 프로젝트가 어떻게 진행되는지 파악 어려움그러면서 깨닫게 됨  웹 디자인은 웹이 동작하는 원리를 알고 그에 맞는 디자인 기획을 짜야함  기본적인 개발 구조 파악 : 프엔, 백엔, DB 등 개발자들이 하는 일이 다 다르다는 걸 인식하게 됨이러한 점을 깨달으며 프로젝트의 어떤 기능에 대해 맞는 개발자와 얘기해야할지, 일정 내 구현이 가능한지에 대해 생각하게 됨결국 웹 개발에 대해 다시 알아야하는 김 양은 HTML, CSS, JS를 공부하며 기초를 다졌고, 자신이 배운 데까지만 기능과 디자인 구현을 하게 됨. ‘프엔 개발자가 되볼까?’ 하는 생각도 들었지만 결국 디자이너로서 가지는 디자인 관점을 포기하고 코드로만 생각하게 되는 자신을 보고 깨달음. 개발 언어, 프로그램 개발 자체가 아니라 나의 회사에서 개발되는 구조, 과정 등을 알고 나의 디자인이 어떻게 구축되는지만 알면 이 관점을 유지하면서 원만히 협업할 수 있구나~하고.결국 디자이너는 사용자에게 어떻게 보이는지, 어떠한 환경에서 어떻게 관리하며 경험 상 어떻게 사용할지 등을 알아 내가 보는 게 아닌 사용자가 실제로 접근하는 것이 최종완성본이란 걸 아는 게 중요함. 그래서 그 이전 개발에 대해 이해하여 개발자와의 소통을 원활히 하면서 디자이너로서 이런 부분을 함께 체크한다면 좋은 협업이 가능할 것임- 우리가 협업을 할 수 있었던 이유위 김 군이 처음 협업할 시 협업을 가능케 했던 이유는 ‘하얀색 도화지’였고 소규모였음, 그래서 서로의 포지션에서 서로의 말을 경청하고 의도를 보다 쉽게 파악할 수 있어 이해 되지 않은 내용은 반복적인 질문, 필요한 정보를 파악 후 빠른 대처가 가능했었음. 즉, 협업의 기본을 다 할 수 있어 원만한 소통이 가능했음.하지만 일반적인 회사에서 근속하며 그러기엔 쉽지 않음. 그러므로 개발자에게 질문을 해 협업에 필요한 개발 지식 습득 등 자신의 회사에 필요한 개발 기술 지식이 무엇인지 빠르게 알아 개발자와의 원만한 협업을 위해 노력하자",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/03/%EC%98%A4%EA%B0%9C%EC%95%88%EB%A7%901.html"
      }
      ,
    
      "ec-9c-a4-ed-83-9c-ec-97-b0-eb-8f-85-ec-84-9c-ec-9d-bc-ec-a7-80-2022-10-01-ec-98-a4-ea-b0-9c-ec-95-88-eb-a7-90-index-ty-html": {
        "title": "윤태연 독서일지: 오개안말 목차 및 기록",
        "tags": "윤태연",
        "date": "October 1, 2022",
        "author": "",
        "category": "",
        "content": "목차와 페이지, 날짜 기록오늘도 개발자가 안 된다고 말했다  내용정리 시작! 한 Part당 소제목 1개씩 읽을 것이다!번호나 • 뒤에 나오는 내용만 읽어도 파악되게 써봤다.PART 01 가깝고도 먼 개발자  어딘가 이상한 비전공자의 협업(p18~p36) : 22/10/03  온몸으로 느낀 개발자(p37~p47) : 22/10/06  협업을 위한 준비물(p48~p52) : 22/10/14PART 02 기획자의 일  서비스 기획 들여다보기(p53~p65) : 22/10/15  협업을 위한 사전 준비(p66~p83) : 22/10/16  협업을 돕는 화면 설계서(p84~p96) : 22/10/19PART 03 디자이너의 일  디자이너의 마인드셋(p97~p110) : 22/10/22  정확한 시각화를 위한 개발 지식(p111~p135) :  협업을 위한 개발 지식(p136~p164) :PART 04 개발자의 일  개발자 이해하기(p165~p184) :  생산성 향상을 위한 협업 툴(p185~p212) :  개발자가 말하는 협업(p213~p233) :",
        "url": "//%EC%9C%A4%ED%83%9C%EC%97%B0/%EB%8F%85%EC%84%9C%EC%9D%BC%EC%A7%80/2022/10/01/%EC%98%A4%EA%B0%9C%EC%95%88%EB%A7%90_Index-TY.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js"></script>
<script src="/assets/js/search.js"></script></section>
</article>

    </div>
    
<script src="/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


    <script id="dsq-count-scr" src="//.disqus.com/count.js" async></script>

    <!-- Google Analytics Tracking code -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', '']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

  </body>
</html>
